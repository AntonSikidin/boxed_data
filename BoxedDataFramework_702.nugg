<?xml version="1.0" encoding="utf-8"?>
<nugget name="BOXED_DATA_FRAMEWORK.NUGG">
 <CLAS CLSNAME="ZCX_BOXED_NO_CHECK" VERSION="1" LANGU="E" DESCRIPT="Boxed NO check exception with text" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_NO_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_NO_CHECK" CMPNAME="TEXT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_BOXED_NO_CHECK" CMPNAME="ZCX_BOXED_NO_CHECK" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_NO_CHECK" REFCLSNAME="CX_NO_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_DATA_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Abstract Boxed Data Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_NO_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_DATA_EXCEPTION" CMPNAME="ZCX_BOXED_DATA_EXCEPTION" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_DATA_EXCEPTION" REFCLSNAME="ZCX_BOXED_NO_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" DESCRIPT="Box Path Dynamic Where Condition Failure Exception (ABAP)" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOX_PATH_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOX_PATH_DYN_COND_FAIL" CMPNAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOX_PATH_DYN_COND_FAIL" REFCLSNAME="ZCX_BOX_PATH_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_STRUCT_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Abstract Boxed Struct Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_STRUCT_EXCEPTION" CMPNAME="ZCX_BOXED_STRUCT_EXCEPTION" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_STRUCT_EXCEPTION" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOX_PATH_TYPE_NOT_NAVIG" VERSION="1" LANGU="E" DESCRIPT="Box Path Data Type Not Navigable Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOX_PATH_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOX_PATH_TYPE_NOT_NAVIG" CMPNAME="ZCX_BOX_PATH_TYPE_NOT_NAVIG" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOX_PATH_TYPE_NOT_NAVIG" REFCLSNAME="ZCX_BOX_PATH_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_QUERY_CLAUSE" VERSION="1" LANGU="E" DESCRIPT="Dynamic Query Clause" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="_CONDITIONS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="6 " SRCCOLUMN2="44 " TYPESRC_LENG="43 " TYPESRC="_conditions type standard table of string
"/>
  <method CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="ADD_CONDITION" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="ADD_CONDITION" SCONAME="OPERATION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="ADD_CONDITION" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>method add_condition.
  data: lv_condition type string.
  lv_condition = zcl_boxed_data_util=&gt;replace_strexp_with_quote( condition ).
  check contains( lv_condition ) eq abap_false.

  if is_valid( condition ) eq abap_false.
    &quot;... RAISE ERROR
  endif.

  if operation is not initial.
    concatenate operation lv_condition into lv_condition.
  endif.

  append lv_condition to _conditions.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="AND" VERSION="1" LANGU="E" DESCRIPT="Logical &apos;AND&apos; query operator~ Returns clause for convenience" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="AND" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="AND" SCONAME="CLAUSE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY_CLAUSE"/>
   <source>method and.
    if lines( _conditions ) gt 0.
      add_condition( operation = &apos;and&apos; condition = condition ).
    else.
      add_condition( condition ).
    endif.

    &quot;... Pass back for syntax joy
    clause = me.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="Provide the base &apos;where&apos; to the input" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="CONSTRUCTOR" SCONAME="WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <source>method constructor.
    add_condition( where ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="CONTAINS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="CONTAINS" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="CONTAINS" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method contains.
    read table _conditions with key table_line = condition transporting no fields.

    if sy-subrc eq 0.
      result = abap_true.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="IS_VALID" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="IS_VALID" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="IS_VALID" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method is_valid.
    result = abap_true.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="OR" VERSION="1" LANGU="E" DESCRIPT="Logical &apos;OR&apos; query operator ~ Returns clause for convenience" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="OR" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="OR" SCONAME="CLAUSE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY_CLAUSE"/>
   <source>method or.
    if lines( _conditions ) gt 0.
      add_condition( operation = &apos;or&apos; condition = condition ).
    else.
      add_condition( condition ).
    endif.

    &quot;... Pass back for syntax joy
    clause = me.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="TO_STRING" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY_CLAUSE" CMPNAME="TO_STRING" SCONAME="STR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method to_string.
  data: lv_str type string.
  loop at _conditions into lv_str.
    if str is not initial.
      &quot;... Space
      concatenate str lv_str into str separated by space.
    else.
      &quot;... No Space
      concatenate str lv_str into str.
    endif.
  endloop.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_STRUCT_NO_SUCH_ATTR" VERSION="1" LANGU="E" DESCRIPT="Boxed Struct No Such Attribute Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_STRUCT_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_STRUCT_NO_SUCH_ATTR" CMPNAME="ZCX_BOXED_STRUCT_NO_SUCH_ATTR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_STRUCT_NO_SUCH_ATTR" REFCLSNAME="ZCX_BOXED_STRUCT_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Object (e.g. any Class or Interface)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCL_BOXED_DATA">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCL_BOXED_OBJECT" REFCLSNAME="ZCL_BOXED_DATA" VERSION="1" STATE="1"/>
  <method CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="CALL" VERSION="1" LANGU="E" DESCRIPT="Calls a method" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="CALL" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method CALL.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="CONSTRUCTOR" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Dont use this, its for the factory performance" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <source>method constructor.
  data: lr_descr type ref to cl_abap_typedescr.

  lr_descr = type_descr.
  if type_descr is initial.
    lr_descr = cl_abap_typedescr=&gt;describe_by_object_ref( value ).
  endif.

  super-&gt;constructor( value = value type_descr = lr_descr ).

  boxed_type = zcl_boxed_packer=&gt;co_type_object.

  if me-&gt;type_descr-&gt;kind ne cl_abap_typedescr=&gt;kind_class and me-&gt;type_descr-&gt;kind ne cl_abap_typedescr=&gt;kind_intf.
    data: lv_text type string.
    lv_text = |The abap type [{ get_abap_type( ) }] does not match the boxed type [{ boxed_type }]|.
    raise exception type zcx_boxed_type_mismatch
      exporting
        text = lv_text.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="METHOD" VERSION="1" LANGU="E" DESCRIPT="Gets a method by name" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="METHOD" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_OBJECT" CMPNAME="METHOD" SCONAME="METHOD" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_METHOD"/>
   <source>method method.
  create object method
    exporting
      name   = name
      object = me.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_QUERY" VERSION="1" LANGU="E" DESCRIPT="Represents a Boxed Dynamic DB Query" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_BOXED_QUERY" CMPNAME="_CLAUSE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY_CLAUSE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_QUERY" CMPNAME="_TABLE_NAME" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="AND" VERSION="1" LANGU="E" DESCRIPT="Appends an AND condition" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="AND" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="AND" SCONAME="QUERY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY"/>
   <source>method and.
    _clause-&gt;and( condition ).

    query = me. &quot;... Convenience return.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="CONSTRUCTOR" SCONAME="TABLE_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>method constructor.
  _table_name = table_name.
  create object _clause.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="DELETE" VERSION="1" LANGU="E" DESCRIPT="Delete table from the preset condition OR &apos;From&apos; the input" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="DELETE" SCONAME="FROM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA" PAROPTIONL="X"/>
   <source>method delete.
  data: lr_data type ref to data,
        lv_condition type string.

  field-symbols: &lt;fs_struct&gt; type any,
                 &lt;fs_table&gt; type any table.

  if from is not initial.
    &quot;... Get the reference
    lr_data = from-&gt;get_data( ).

    case from-&gt;boxed_type.
      when zcl_boxed_packer=&gt;co_type_tableset.
        assign lr_data-&gt;* to &lt;fs_table&gt;. &quot;... Assign the table FS

        &quot;... Do insert
        delete (_table_name) from table &lt;fs_table&gt;.
      when zcl_boxed_packer=&gt;co_type_struct.
        assign lr_data-&gt;* to &lt;fs_struct&gt;. &quot;... Assign the structure FS

        &quot;... Do insert
        delete (_table_name) from &lt;fs_struct&gt;.
      when others.
        &quot;... NOT SUPPORTED
    endcase.
  else.
    lv_condition = _clause-&gt;to_string( ).
    delete from (_table_name) where (lv_condition).
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="GET_CLAUSE" VERSION="1" LANGU="E" DESCRIPT="Returns the current clause" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="GET_CLAUSE" SCONAME="CLAUSE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY_CLAUSE"/>
   <source>method get_clause.
    clause = _clause.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="INSERT" VERSION="1" LANGU="E" DESCRIPT="Insert into the table from the input" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="INSERT" SCONAME="FROM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method insert.
  data: lr_data type ref to data.
  field-symbols: &lt;fs_struct&gt; type any,
                 &lt;fs_table&gt; type any table.

  &quot;... Get the reference
  lr_data = from-&gt;get_data( ).

  case from-&gt;boxed_type.
    when zcl_boxed_packer=&gt;co_type_tableset.
      assign lr_data-&gt;* to &lt;fs_table&gt;. &quot;... Assign the table FS

      &quot;... Do insert
      insert (_table_name) from table &lt;fs_table&gt;.
    when zcl_boxed_packer=&gt;co_type_struct.
      assign lr_data-&gt;* to &lt;fs_struct&gt;. &quot;... Assign the structure FS

      &quot;... Do insert
      insert (_table_name) from &lt;fs_struct&gt;.
    when others.
      &quot;... NOT SUPPORTED
  endcase.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="MODIFY" VERSION="1" LANGU="E" DESCRIPT="Modifies the table from an input table" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="MODIFY" SCONAME="FROM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method modify.
  data: lr_data type ref to data.
  field-symbols: &lt;fs_struct&gt; type any,
                 &lt;fs_table&gt; type any table.

  &quot;... Get the reference
  lr_data = from-&gt;get_data( ).

  case from-&gt;boxed_type.
    when zcl_boxed_packer=&gt;co_type_tableset.
      assign lr_data-&gt;* to &lt;fs_table&gt;. &quot;... Assign the table FS

      &quot;... Do insert
      modify (_table_name) from table &lt;fs_table&gt;.
    when zcl_boxed_packer=&gt;co_type_struct.
      assign lr_data-&gt;* to &lt;fs_struct&gt;. &quot;... Assign the structure FS

      &quot;... Do insert
      modify (_table_name) from &lt;fs_struct&gt;.
    when others.
      &quot;... NOT SUPPORTED
  endcase.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="OR" VERSION="1" LANGU="E" DESCRIPT="Appends an OR condition" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="OR" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="OR" SCONAME="QUERY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY"/>
   <source>method or.
    _clause-&gt;or( condition ).

    query = me. &quot;... Convenience return.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="SELECT" VERSION="1" LANGU="E" DESCRIPT="Selects 0..n entries into a tableset" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="SELECT" SCONAME="COLUMNS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="SELECT" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_TABLESET"/>
   <source>method select.
  data: lr_data type ref to data,
        lv_columns type string,
        lv_where type string.
  field-symbols: &lt;fs_table&gt; type any table.

  &quot;... Set up the type for selecton
  create data lr_data type standard table of (_table_name).
  assign lr_data-&gt;* to &lt;fs_table&gt;.

  lv_columns = columns.

  if lv_columns is initial.
    lv_columns = &apos;*&apos;.
  endif.

  lv_where = _clause-&gt;to_string( ).

  select (lv_columns) from (_table_name) into table &lt;fs_table&gt; where (lv_where).

  &quot;... Box the result
  result ?= zcl_boxed_packer=&gt;box( &lt;fs_table&gt; ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="SELECT_SINGLE" VERSION="1" LANGU="E" DESCRIPT="Selects 0..1 entry into a structure" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="SELECT_SINGLE" SCONAME="COLUMNS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="SELECT_SINGLE" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_STRUCT"/>
   <source>method select_single.
  data: lr_data type ref to data,
        lv_where type string,
        lv_columns type string.
  field-symbols: &lt;fs_line&gt; type any.

  &quot;... Set up the type for selecton
  create data lr_data type (_table_name).
  assign lr_data-&gt;* to &lt;fs_line&gt;.

  lv_columns = columns.

  if lv_columns is initial.
    lv_columns = &apos;*&apos;.
  endif.

  lv_where = _clause-&gt;to_string( ).

  select single (lv_columns) from (_table_name) into &lt;fs_line&gt; where (lv_where).

  &quot;... Box the result
  result ?= zcl_boxed_packer=&gt;box( &lt;fs_line&gt; ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="UPDATE" VERSION="1" LANGU="E" DESCRIPT="Updates the table from an input table" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="UPDATE" SCONAME="FROM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method update.
  data: lr_data type ref to data.
  field-symbols: &lt;fs_struct&gt; type any,
                 &lt;fs_table&gt; type any table.

  &quot;... Get the reference
  lr_data = from-&gt;get_data( ).

  case from-&gt;boxed_type.
    when zcl_boxed_packer=&gt;co_type_tableset.
      assign lr_data-&gt;* to &lt;fs_table&gt;. &quot;... Assign the table FS

      &quot;... Do insert
      update (_table_name) from table &lt;fs_table&gt;.
    when zcl_boxed_packer=&gt;co_type_struct.
      assign lr_data-&gt;* to &lt;fs_struct&gt;. &quot;... Assign the structure FS

      &quot;... Do insert
      update (_table_name) from &lt;fs_struct&gt;.
    when others.
      &quot;... NOT SUPPORTED
  endcase.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="USING" VERSION="1" LANGU="E" DESCRIPT="Clause to use [instead of &apos;where()&apos;]" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="USING" SCONAME="CLAUSE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY_CLAUSE"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="USING" SCONAME="QUERY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY"/>
   <source>method using.
    _clause = clause.

    query = me. &quot;... Convenience return.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_QUERY" CMPNAME="WHERE" VERSION="1" LANGU="E" DESCRIPT="Where condition to use [instead of &apos;using()&apos;]" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="WHERE" SCONAME="CONDITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_QUERY" CMPNAME="WHERE" SCONAME="QUERY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_QUERY"/>
   <source>method where.
  &quot;... When where is used a new query clause is always created
  create object _clause
    exporting
      where = condition.

  query = me. &quot;... Convenience return.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_METHOD" VERSION="1" LANGU="E" DESCRIPT="For use in a boxed object" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_BOXED_METHOD" CMPNAME="BOXED_ATTR" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="22 " TYPESRC_LENG="0 " TYPESRC="begin of boxed_attr,
        name type string,
        data type ref to zcl_boxed_data,
      end of boxed_attr
"/>
  <friends CLSNAME="ZCL_BOXED_METHOD" REFCLSNAME="ZCL_BOXED_OBJECT" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_BOXED_METHOD" CMPNAME="_BOXED_ATTR" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="17 " SRCCOLUMN2="67 " TYPESRC_LENG="66 " TYPESRC="_boxed_attr type hashed table of boxed_attr with unique key name
"/>
  <attribute CLSNAME="ZCL_BOXED_METHOD" CMPNAME="_DEFINITIONS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_PARMDESCR_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_METHOD" CMPNAME="_DESCR" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_OBJECTDESCR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_METHOD" CMPNAME="_NAME" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_METHOD" CMPNAME="_OBJECT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_BOXED_OBJECT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_METHOD" CMPNAME="_PARMS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_PARMBIND_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CALL" VERSION="1" LANGU="E" DESCRIPT="Call this method" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CALL" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method call.
  data: lr_obj type ref to object,
        lr_data type ref to data,
        ls_parm type line of abap_parmbind_tab.
  field-symbols: &lt;fs_obj&gt; type any,
             &lt;fs_value&gt; type any.
  lr_data = _object-&gt;get_data( ).
  assign lr_data-&gt;* to &lt;fs_obj&gt;.

  lr_obj = &lt;fs_obj&gt;.
  call method lr_obj-&gt;(_name) parameter-table _parms.

  read table _parms with key kind = cl_abap_objectdescr=&gt;returning into ls_parm.

  if sy-subrc eq 0.
    assign ls_parm-value-&gt;* to &lt;fs_value&gt;.
    result = zcl_boxed_packer=&gt;box( &lt;fs_value&gt; ).
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CHANGE" VERSION="1" LANGU="E" DESCRIPT="Changing, if name excluded goes in order of parm" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CHANGE" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CHANGE" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CHANGE" SCONAME="CALLBACK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_METHOD"/>
   <source>method change.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CONSTRUCTOR" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="CONSTRUCTOR" SCONAME="OBJECT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_OBJECT"/>
   <source>method constructor.
  data: ls_method type line of abap_methdescr_tab.
  _name = |{ name case = upper }|.

  _descr ?= object-&gt;get_descriptor( ).

  read table _descr-&gt;methods into ls_method with key name = _name.

  _definitions = ls_method-parameters.
  _object = object.

  init( ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="EXPORT" VERSION="1" LANGU="E" DESCRIPT="Exporting, if name excluded goes in order of parm" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="EXPORT" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="EXPORT" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="EXPORT" SCONAME="CALLBACK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_METHOD"/>
   <source>method export.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="GET_BOXED_ATTR" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="GET_BOXED_ATTR" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="GET_BOXED_ATTR" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method get_boxed_attr.
  data: ls_attr type boxed_attr,
        ls_def type line of abap_parmdescr_tab,
        lr_type type ref to cl_abap_datadescr,
        lv_type type string.
  field-symbols: &lt;fs_attr&gt; type boxed_attr,
                 &lt;fs_value&gt; type any.

  read table _boxed_attr with key name = name assigning &lt;fs_attr&gt;.

  if sy-subrc eq 0.
    boxed_data = &lt;fs_attr&gt;-data.
  else.

    &quot;... Initialise any returns
    read table _definitions with key name = name into ls_def.

    data: ls_parm like line of _parms.

    lr_type = _descr-&gt;get_method_parameter_type( p_method_name = _name
                                                       p_parameter_name = name ).

    lv_type = lr_type-&gt;get_relative_name( ).

    ls_parm-name = name.
    case ls_def-parm_kind.
      when cl_abap_objectdescr=&gt;importing.
        ls_parm-kind = cl_abap_objectdescr=&gt;exporting.
      when cl_abap_objectdescr=&gt;exporting.
        ls_parm-kind = cl_abap_objectdescr=&gt;importing.
      when others.
        ls_parm-kind = ls_def-parm_kind.
    endcase.

    create data ls_parm-value type (lv_type).
    insert ls_parm into table _parms.

    assign ls_parm-value-&gt;* to &lt;fs_value&gt;.

    boxed_data = zcl_boxed_packer=&gt;internal_box( value = &lt;fs_value&gt;
                                                 type_descr = lr_type ).

    &quot;... Override memory area
    boxed_data-&gt;data = ls_parm-value.

    ls_attr-name = name.
    ls_attr-data = boxed_data.
    insert ls_attr into table _boxed_attr.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="IMPORT" VERSION="1" LANGU="E" DESCRIPT="Importing, if name excluded goes in order of parm" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="IMPORT" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="IMPORT" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="IMPORT" SCONAME="CALLBACK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_METHOD"/>
   <source>method import.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="INIT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method init.
  data: ls_def type line of abap_parmdescr_tab.

  &quot;... Initialise any returns
  read table _definitions with key parm_kind = cl_abap_objectdescr=&gt;returning into ls_def.

  if sy-subrc eq 0.

  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_METHOD" CMPNAME="PARM" VERSION="1" LANGU="E" DESCRIPT="Set a parm with name then set_value()" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="PARM" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_METHOD" CMPNAME="PARM" SCONAME="PARM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method parm.
    data lv_name type string.
    lv_name = |{ name case = upper }|.

    parm = get_boxed_attr( lv_name ).
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_TABLE_INDEX_NOT_SUPP" VERSION="1" LANGU="E" DESCRIPT="Boxed Table Index Not Supported Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_TABLE_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_TABLE_INDEX_NOT_SUPP" CMPNAME="ZCX_BOXED_TABLE_INDEX_NOT_SUPP" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_TABLE_INDEX_NOT_SUPP" REFCLSNAME="ZCX_BOXED_TABLE_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOX_PATH" VERSION="1" LANGU="E" DESCRIPT="Box path object for navigating Boxed Data" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_BOX_PATH" CMPNAME="BOXED_LINE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="25 " TYPESRC_LENG="0 " TYPESRC="begin of boxed_line,
          name type string,
          boxed_data type ref to zcl_boxed_data,
         end of boxed_line
"/>
  <types CLSNAME="ZCL_BOX_PATH" CMPNAME="BOXED_DATA_TAB" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="51 " TYPESRC_LENG="0 " TYPESRC="BOXED_DATA_TAB type standard table of boxed_line
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_BOX_PATH" CMPNAME="PATH" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="Constructs a new path object" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="CONSTRUCTOR" SCONAME="PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <exception CLSNAME="ZCL_BOX_PATH" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_BOX_PATH_INVALID_FORMAT" VERSION="1" LANGU="E" DESCRIPT="Box Path Invalid Format Exception" MTDTYPE="2" EDITORDER="1 "/>
   <source>method constructor.
    me-&gt;path = path.

    &quot;... Validate the path!
    validate_path( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="EVALUATE" VERSION="1" LANGU="E" DESCRIPT="Evaluates the result of a valid path" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="EVALUATE" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="EVALUATE" SCONAME="ACCESSORS" VERSION="1" LANGU="E" DESCRIPT="Table with Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRINGTAB"/>
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="EVALUATE" SCONAME="RESULT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOX_PATH" CMPNAME="EVALUATE" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" DESCRIPT="Box Path Dynamic Where Condition Failure Exception (ABAP)" MTDTYPE="0" EDITORDER="1 "/>
   <source>method evaluate.
  data: lt_tab like accessors.
  field-symbols: &lt;fs_accessor&gt; type string.

  lt_tab = accessors.

  &quot;... Set the result
  result = boxed_data.

  loop at lt_tab assigning &lt;fs_accessor&gt;.
    &quot;... Handles any where condition
    insert_where_cond( changing accessor = &lt;fs_accessor&gt; tab = lt_tab ).

    case result-&gt;boxed_type.
      when zcl_boxed_packer=&gt;co_type_struct.
        data: lr_struct type ref to zcl_boxed_struct.
        lr_struct ?= result .

        result = lr_struct-&gt;get_attribute( &lt;fs_accessor&gt; ).
      when zcl_boxed_packer=&gt;co_type_tableset.
        data: lr_table type ref to zcl_boxed_tableset.
        lr_table ?= result.

*          replace all occurrences of regex &apos;(\[|\])&apos; in &lt;fs_accessor&gt; with &apos;&apos;.
        replace regex `(\[)(.*)(\])` in &lt;fs_accessor&gt; with `$2`.
        if sy-subrc ne 0.
          raise_not_navigable( boxed_data = result accessor = &lt;fs_accessor&gt; ).
        endif.

        result = lr_table-&gt;find( &lt;fs_accessor&gt; ).
        if result is initial.
          return.
        endif.
      when others.
        raise_not_navigable( boxed_data = result accessor = &lt;fs_accessor&gt; ).
    endcase.
  endloop.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="GET_PATH" VERSION="1" LANGU="E" DESCRIPT="Gets the constructed path" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="GET_PATH" SCONAME="PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method get_path.
    path = me-&gt;path.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="INSERT_WHERE_COND" VERSION="1" LANGU="E" DESCRIPT="Deals with the [ abap_cond ] in path accessor table" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="INSERT_WHERE_COND" SCONAME="ACCESSOR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="INSERT_WHERE_COND" SCONAME="TAB" VERSION="1" LANGU="E" DESCRIPT="Table with Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRINGTAB"/>
   <source>method insert_where_cond.
    data: lv_tabfind type string.
    lv_tabfind = substring_from( val = accessor sub = &apos;[&apos; ).

    if lv_tabfind is not initial and lv_tabfind ne accessor.
      accessor = substring_before( val = accessor sub = &apos;[&apos; ).
      insert lv_tabfind into tab index sy-tabix + 1.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="LOCATE" VERSION="1" LANGU="E" DESCRIPT="Resolves a valid attribute to return a boxed data object" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="LOCATE" SCONAME="ACCESSORS" VERSION="1" LANGU="E" DESCRIPT="Table with Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRINGTAB"/>
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="LOCATE" SCONAME="BOXED_DATA_TAB" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOXED_DATA_TAB"/>
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="LOCATE" SCONAME="RESULT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method locate.
  data: ls_box type boxed_line,
        ls_new type boxed_line,
        lv_accessor type string,
        lt_box type boxed_data_tab,
        lt_accessors like accessors.
  field-symbols: &lt;fs_accessor&gt; type string,
                  &lt;fs_component&gt; type line of abap_component_symbol_tab.
  lt_accessors = accessors.

  &quot;...locate the first element in the wildcard.
  read table lt_accessors index 1 assigning &lt;fs_accessor&gt;.
  if sy-subrc ne 0.
    clear result.
    return.
  endif.

  &quot;... Handles any where condition
  insert_where_cond( changing accessor = &lt;fs_accessor&gt; tab = lt_accessors ).

  &quot;... Need upper case for comparison later
  lv_accessor = |{ &lt;fs_accessor&gt; case = upper }|.

  &quot;...get each boxed component out of the internal box table.
  loop at boxed_data_tab into ls_box.
    result = ls_box-boxed_data.

    case result-&gt;boxed_type.
      when zcl_boxed_packer=&gt;co_type_struct.
        data: lr_struct type ref to zcl_boxed_struct,
              lt_components type abap_component_symbol_tab.
        lr_struct ?= result.
        lt_components = lr_struct-&gt;get_components( ).

        &quot;... Try to end quick
        read table lt_components with key name = lv_accessor transporting no fields.

        if sy-subrc eq 0. &quot;... Found the item here
          replace &apos;*&apos; in path with ls_box-name.
          result = evaluate( boxed_data = lr_struct accessors = lt_accessors ).
          return.
        endif.

        &quot;... Otherwise we end up with a table of boxed components which exist at the next level.
        loop at lt_components assigning &lt;fs_component&gt;.
          clear ls_new.

          &quot;... only tableset or struct are navigable
          case &lt;fs_component&gt;-type-&gt;kind.
            when &lt;fs_component&gt;-type-&gt;kind_table or &lt;fs_component&gt;-type-&gt;kind_struct.
              data: boxed_comp type ref to zcl_boxed_data,
                    lv_attr type string.
              boxed_comp = lr_struct-&gt;get_attribute( |{ &lt;fs_component&gt;-name }| ).


              ls_new-boxed_data = boxed_comp.
              if ls_box-name is initial.
                ls_new-name = |{ &lt;fs_component&gt;-name }|.
              else.
                ls_new-name = |{ ls_box-name }-{ &lt;fs_component&gt;-name }|.
              endif.
              append ls_new to lt_box.
          endcase.
        endloop.

        &quot;...evaluate will find using the specified criteria.
      when zcl_boxed_packer=&gt;co_type_tableset.
*          find all occurrences of regex &apos;\[([^]]+)\]&apos; in lv_accessor match length data(lv_match_length).
*          if strlen( |{ lv_accessor }| ) eq lv_match_length.
        if lv_accessor(1) eq &apos;[&apos;.
          replace &apos;*-&apos; in path with ls_box-name.
          result = evaluate( boxed_data = result accessors = lt_accessors ).
          return.
        endif.
    endcase.
  endloop.

  &quot;...search the next level of components
  if lt_box is not initial.
    result = locate( boxed_data_tab = lt_box accessors = lt_accessors ).
    if result is not initial.
      return.
    endif.
  endif.

  &quot;... Clear result because its not found
  clear result.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="RAISE_NOT_NAVIGABLE" VERSION="1" LANGU="E" DESCRIPT="Raises the not navigable exception" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="RAISE_NOT_NAVIGABLE" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" DESCRIPT="Boxed Data" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="RAISE_NOT_NAVIGABLE" SCONAME="ACCESSOR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <exception CLSNAME="ZCL_BOX_PATH" CMPNAME="RAISE_NOT_NAVIGABLE" SCONAME="ZCX_BOX_PATH_TYPE_NOT_NAVIG" VERSION="1" LANGU="E" DESCRIPT="Box Path Data Type Not Navigable Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>method raise_not_navigable.
    data: lv_text type string.
    lv_text = |The boxed type [{ boxed_data-&gt;boxed_type }], containing data [{ boxed_data-&gt;get_abap_type( ) }]|.
    lv_text = |{ lv_text } is not navigable via path attribute [&apos;{ accessor }&apos;] in the path &apos;{ path }&apos;|.
    raise exception type zcx_box_path_type_not_navig
      exporting
        text = lv_text.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="RESOLVE" VERSION="1" LANGU="E" DESCRIPT="Resolves a valid box path to return a boxed data object" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="RESOLVE" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <parameter CLSNAME="ZCL_BOX_PATH" CMPNAME="RESOLVE" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOX_PATH" CMPNAME="RESOLVE" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" DESCRIPT="Box Path Dynamic Where Condition Failure Exception (ABAP)" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_BOX_PATH" CMPNAME="RESOLVE" SCONAME="ZCX_BOX_PATH_TYPE_NOT_NAVIG" VERSION="1" LANGU="E" DESCRIPT="Box Path Data Type Not Navigable Exception" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_BOX_PATH" CMPNAME="RESOLVE" SCONAME="ZCX_BOXED_STRUCT_NO_SUCH_ATTR" VERSION="1" LANGU="E" DESCRIPT="Boxed Struct No Such Attribute Exception" MTDTYPE="0" EDITORDER="3 "/>
   <source>method resolve.
  data: lt_tab type standard table of string,
        ls_box type boxed_line,
        lr_box type ref to zcl_boxed_data,
        lv_wild type abap_bool,
        lt_box type boxed_data_tab,
        lv_path type string.

  lv_path = path.

  if boxed_data-&gt;boxed_type eq zcl_boxed_packer=&gt;co_type_ref.
    data: lr_ref type ref to zcl_boxed_ref.
    lr_ref ?= boxed_data.
    lr_box = lr_box = lr_ref-&gt;to_source( ).
  else.
    lr_box = boxed_data.
  endif.

  replace &apos;*-&apos; in lv_path with &apos;&apos;.

  if sy-subrc eq 0.
    lv_wild = abap_true.
  endif.

  &quot;... Split the path
  split lv_path at &apos;-&apos; into table lt_tab.

  if lv_wild eq abap_true.
    ls_box-boxed_data = lr_box.
    append ls_box to lt_box.

    result = locate( boxed_data_tab = lt_box accessors = lt_tab ).
  else.
    result = evaluate( boxed_data = lr_box accessors = lt_tab ).
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOX_PATH" CMPNAME="VALIDATE_PATH" VERSION="1" LANGU="E" DESCRIPT="Validates the path format" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_BOX_PATH" CMPNAME="VALIDATE_PATH" SCONAME="ZCX_BOX_PATH_INVALID_FORMAT" VERSION="1" LANGU="E" DESCRIPT="Box Path Invalid Format Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>method validate_path.
    &quot;... This regex matches correctly but is slower by 800mu
*    data: lv_regex type string value `^(((\*-)?([a-zA-Z_]+))?(\[.*[^\[\]]\])?)((-([a-zA-Z_]+))?(\[.*[^\[\]]\])?)*$`.

    &quot;...get path.
    data: lv_path type string.
    lv_path = me-&gt;path.

    &quot;...remove any search clauses (contained in square brackets) from the path.
    replace all occurrences of regex &apos;\[([^]]+)\]&apos; in lv_path with &apos;&apos;.

    &quot;...find any invalid characters in the path.
    data: lv_match_length type string.
    find all occurrences of regex &apos;^\*\-|^\*\-[a-zA-Z0-9._-]+|[a-zA-Z0-9._-]+&apos; in lv_path match length lv_match_length.

    &quot;...if the number of characters in the path exceed the number of valid characters we know the path is invalid.
    if strlen( lv_path ) &gt; lv_match_length.
      data: lv_text type string.
      lv_text = |The provided path [&apos;{ lv_path }&apos;] does not match an accepted format e.g. |.
      lv_text = |{ lv_text }&apos;structure-table[key = \|value\|]-attribute&apos;|.
      raise exception type zcx_box_path_invalid_format
        exporting
          text = lv_text.
    endif.
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOX_PATH_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Box Path Abstract Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOX_PATH_EXCEPTION" CMPNAME="ZCX_BOX_PATH_EXCEPTION" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOX_PATH_EXCEPTION" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_ELEMENT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Element (e.g. a String or other singular value)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCL_BOXED_DATA">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCL_BOXED_ELEMENT" REFCLSNAME="ZCL_BOXED_DATA" VERSION="1" STATE="1"/>
  <method CLSNAME="ZCL_BOXED_ELEMENT" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_ELEMENT" CMPNAME="CONSTRUCTOR" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_ELEMENT" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Dont use this, its for the factory performance" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <source>method constructor.
    super-&gt;constructor( value = value type_descr = type_descr ).

    boxed_type = zcl_boxed_packer=&gt;co_type_element.

    if me-&gt;type_descr-&gt;kind ne cl_abap_typedescr=&gt;kind_elem.
      data: lv_text type string.
      lv_text = |The abap type [{ get_abap_type( ) }] does not match the boxed type [{ boxed_type }]|.
      raise exception type zcx_boxed_type_mismatch
        exporting
          text = lv_text.
    endif.
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_STRUCT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Structure (an abap Structure)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCL_BOXED_COMPLEX_TYPE">
  <types CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="ZBOXED_COMPONENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="82 " TYPESRC_LENG="0 " TYPESRC="zboxed_components type hashed table of abap_componentdescr with unique key name
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_BOXED_STRUCT" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="COMPONENTS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_COMPONENT_SYMBOL_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_BOXED_STRUCT" REFCLSNAME="ZCL_BOXED_COMPLEX_TYPE" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_BOXED_STRUCT" REFCLSNAME="ZCL_BOXED_COMPLEX_TYPE" VERSION="1" MTDNAME="TO_STRING" EXPOSURE="2"/>
  </inheritance>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="CONSTRUCTOR" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Dont use this, its for the factory performance" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <source>method constructor.
    super-&gt;constructor( value = value type_descr = type_descr ).

    boxed_type = zcl_boxed_packer=&gt;co_type_struct.

    if me-&gt;type_descr-&gt;kind ne cl_abap_typedescr=&gt;kind_struct.
      data: lv_text type string.
      lv_text = |The abap type [{ get_abap_type( ) }] does not match the boxed type [{ boxed_type }]|.
      raise exception type zcx_boxed_type_mismatch
        exporting
          text = lv_text.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="Gets the value of an attribute as a boxed data object" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_ATTRIBUTE" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_ATTRIBUTE" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_ATTRIBUTE" SCONAME="ZCX_BOXED_STRUCT_NO_SUCH_ATTR" VERSION="1" LANGU="E" DESCRIPT="Boxed Struct No Such Attribute Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>method get_attribute.
  data: lr_descr type ref to cl_abap_typedescr,
        lv_name type string.
  field-symbols: &lt;fs_attributes&gt; type any,
                 &lt;fs_field&gt; type any.
  assign data-&gt;* to &lt;fs_attributes&gt;.
  lv_name = |{ name case = upper }|.
  assign component lv_name of structure &lt;fs_attributes&gt; to &lt;fs_field&gt;.
  if sy-subrc ne 0.
    data: lv_text type string.
    lv_text = |The attribute [{ name }] does not exist in the structure [{ get_abap_type( ) }]|.
    raise exception type zcx_boxed_struct_no_such_attr
      exporting
        text = lv_text.
  endif.

  &quot;... Create the boxed data
  lr_descr = get_comp_descr( name ).
  if lr_descr is not initial.
    boxed_data = zcl_boxed_packer=&gt;internal_box( value = &lt;fs_field&gt; type_descr = lr_descr ).
  else.
    boxed_data = zcl_boxed_packer=&gt;box( &lt;fs_field&gt; ).
  endif.

  &quot;... Override the reference with the actual memory
  get reference of &lt;fs_field&gt; into boxed_data-&gt;data.

  &quot;... Transfer any bindings
  transfer_bindings( path = name boxed_data = boxed_data ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_ATTRIBUTES" VERSION="1" LANGU="E" DESCRIPT="Moves corresponding values TO a supplied structure" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_ATTRIBUTES" SCONAME="ATTRIBUTES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method get_attributes.
    field-symbols: &lt;fs_attributes&gt; type any,
                   &lt;fs_field&gt; type any.
    assign data-&gt;* to &lt;fs_attributes&gt;.
    move-corresponding &lt;fs_attributes&gt; to attributes.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_COMPONENTS" VERSION="1" LANGU="E" DESCRIPT="Get the components of a struct" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_COMPONENTS" SCONAME="COMPONENTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_COMPONENT_SYMBOL_TAB"/>
   <source>method get_components.
  if me-&gt;components is initial.
    data: lr_descr type ref to cl_abap_structdescr.
    lr_descr ?= me-&gt;type_descr.
    me-&gt;components = lr_descr-&gt;get_included_view( ).
  endif.
  components = me-&gt;components.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_COMP_DESCR" VERSION="1" LANGU="E" DESCRIPT="Get the descriptor for a component" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_COMP_DESCR" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="GET_COMP_DESCR" SCONAME="DESCR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <source>method get_comp_descr.
  data: lv_name type string.
  field-symbols: &lt;fs_comp&gt; type line of abap_component_symbol_tab.
  lv_name = name. translate lv_name to upper case.

  if components is initial.
    return.
  endif.

  read table components with key name = lv_name assigning &lt;fs_comp&gt;.

  if sy-subrc eq 0.
    descr = &lt;fs_comp&gt;-type.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="HAS_ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="Check if the attribute exists in a structure" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="HAS_ATTRIBUTE" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="HAS_ATTRIBUTE" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method has_attribute.
  data: lv_name type string.
  field-symbols: &lt;fs_attributes&gt; type any,
                 &lt;fs_field&gt; type any.
  lv_name = name. translate lv_name to upper case.
  assign data-&gt;* to &lt;fs_attributes&gt;.
  assign component lv_name of structure &lt;fs_attributes&gt; to &lt;fs_field&gt;.

  if sy-subrc eq 0.
    result = abap_true.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="SET_ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="Sets the value of an attribute" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="SET_ATTRIBUTE" SCONAME="NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="SET_ATTRIBUTE" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="SET_ATTRIBUTE" SCONAME="ZCX_BOXED_STRUCT_NO_SUCH_ATTR" VERSION="1" LANGU="E" DESCRIPT="Boxed Struct No Such Attribute Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>method set_attribute.
  data: lr_box type ref to zcl_boxed_data.
  &quot;... Check type
  lr_box = get_attribute( name ).

  lr_box-&gt;set_value( value ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="SET_ATTRIBUTES" VERSION="1" LANGU="E" DESCRIPT="Moves corresponding values FROM a supplied structure" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_STRUCT" CMPNAME="SET_ATTRIBUTES" SCONAME="ATTRIBUTES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method set_attributes.
    field-symbols: &lt;fs_attributes&gt; type any,
                   &lt;fs_field&gt; type any.
    assign data-&gt;* to &lt;fs_attributes&gt;.
    move-corresponding attributes to &lt;fs_attributes&gt;.

    &quot;... Deal with bindings if set which is kinda horrible
*    loop at bindings into data(ls_binding).
*      data(lr_box) = zcl_boxed_packer=&gt;box( attributes ).
*
*
*    endloop.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_COMPLEX_TYPE" CMPNAME="TO_STRING" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method to_string.
  data: lt_components type abap_component_symbol_tab,
        ls_comp type line of abap_component_symbol_tab,
        lv_comp_name type string,
        lv_field type string,
        lr_field type ref to zcl_boxed_data.

  lt_components = get_components( ).

  loop at lt_components into ls_comp.
    lr_field = get_attribute( ls_comp-name ).
    if str_value is not initial.
      concatenate str_value cl_abap_char_utilities=&gt;cr_lf into str_value.
    endif.

    lv_comp_name = ls_comp-name. translate lv_comp_name to upper case.
    lv_field = lr_field-&gt;to_string( ).

    concatenate str_value lv_comp_name &apos;:&apos; lv_field into str_value.
  endloop.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_VALUE_MISMATCH" VERSION="1" LANGU="E" DESCRIPT="Boxed Value Mismatch Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_DATA_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_VALUE_MISMATCH" CMPNAME="ZCX_BOXED_VALUE_MISMATCH" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_VALUE_MISMATCH" REFCLSNAME="ZCX_BOXED_DATA_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_VALUE_NODE" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Value Node (can be used in UI)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCL_BOXED_STRUCT">
  <implementing CLSNAME="ZCL_BOXED_VALUE_NODE" REFCLSNAME="IF_BOL_BO_PROPERTY_ACCESS" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCL_BOXED_VALUE_NODE" REFCLSNAME="ZCL_BOXED_STRUCT" VERSION="1" STATE="1"/>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTIES">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTIES.
    get_attributes( importing attributes = es_attributes ).
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY.
    rv_result = get_attribute( |{ iv_attr_name }| )-&gt;get_data( ).
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY_AS_STRING">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY_AS_STRING.
    &quot;... Requires enhancement to use ISO formatting
    rv_result = get_attribute( |{ iv_attr_name }| )-&gt;to_string( ).
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY_AS_VALUE">
   <source>method if_bol_bo_property_access~get_property_as_value.
  data: lv_attr type string,
        lr_box type ref to zcl_boxed_data.

  lv_attr = iv_attr_name.
  lr_box = get_attribute( lv_attr ).
  lr_box-&gt;get_value( importing value = ev_result ).
endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY_TEXT">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY_TEXT.
    &quot;... Not implemented in standard
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY_TEXTS">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~GET_PROPERTY_TEXTS.
    &quot;... Not implemented in standard
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~IS_PROPERTY_MANDATORY">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~IS_PROPERTY_MANDATORY.
    rv_result = abap_undefined.
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~IS_PROPERTY_READONLY">
   <source>method if_bol_bo_property_access~is_property_readonly.
    rv_result = if_genil_boolean=&gt;false.
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~SET_PROPERTIES">
   <source>method if_bol_bo_property_access~set_properties.
    data: lr_data type ref to data.
    field-symbols: &lt;line&gt; type any.

    create data lr_data like is_attributes.
    assign lr_data-&gt;* to &lt;line&gt;.

    if sy-subrc = 0.
      set_attributes( &lt;line&gt; ).
    endif.
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~SET_PROPERTY">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~SET_PROPERTY.
    set_attribute( name = |{ iv_attr_name }| value = iv_value ).
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_BOXED_VALUE_NODE" CPDNAME="IF_BOL_BO_PROPERTY_ACCESS~SET_PROPERTY_AS_STRING">
   <source>method IF_BOL_BO_PROPERTY_ACCESS~SET_PROPERTY_AS_STRING.
    &quot;... A bunch of additional conversions should be added TODO
    set_attribute( name = |{ iv_attr_name }| value = iv_value ).
  endmethod.</source>
  </interfaceMethod>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_DATA" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_BOXED_DATA" CMPNAME="BINDING_STRUCT" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="28 " TYPESRC_LENG="0 " TYPESRC="begin of binding_struct,
          source_path type string,
          target type ref to zcl_boxed_data,
          conformer type ref to zif_boxed_conformer,
        end of binding_struct
"/>
  <friends CLSNAME="ZCL_BOXED_DATA" REFCLSNAME="ZCL_BOXED_METHOD" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_BOXED_DATA" REFCLSNAME="ZCL_BOXED_PACKER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_BOXED_DATA" REFCLSNAME="ZCL_BOX_PATH" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_BOXED_DATA" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_BOXED_DATA" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_BOXED_DATA" CMPNAME="BINDINGS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="16 " SRCCOLUMN2="49 " TYPESRC_LENG="48 " TYPESRC="bindings type standard table of binding_struct
"/>
  <attribute CLSNAME="ZCL_BOXED_DATA" CMPNAME="BOXED_TYPE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_DATA" CMPNAME="DATA" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_DATA" CMPNAME="DATA_TYPE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_DATA" CMPNAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Runtime Type Services" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="ADD_BINDING" VERSION="1" LANGU="E" DESCRIPT="Adds a binding to this boxed data" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="ADD_BINDING" SCONAME="TARGET" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="ADD_BINDING" SCONAME="SOURCE_PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="ADD_BINDING" SCONAME="CONFORMER" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_BOXED_CONFORMER" PAROPTIONL="X"/>
   <source>method add_binding.
    data ls_binding type binding_struct.
    ls_binding-source_path = source_path.
    ls_binding-target = target.
    ls_binding-conformer = conformer.
    append ls_binding to bindings.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="BIND" VERSION="1" LANGU="E" DESCRIPT="Binds a target binding returning the result for convenience" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="BIND" SCONAME="BINDING" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Binding" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_MAPPING"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="BIND" SCONAME="BINDING_MODE" VERSION="1" LANGU="E" DESCRIPT="2 way or 1 way binding" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="2"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="BIND" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method bind.
* REMOVED INCOMPATIBLE FOR NOW WITH 7.0
*====================================================
* Binding is the same functionality as mapping
* However at the end the binding is added for each iteration
* Not yet implemented, soon to come
*====================================================
*    data: lt_split type standard table of string,
*          lr_source type ref to zcl_boxed_data,
*          lr_src_path type ref to zcl_box_path,
*          lr_tgt_path type ref to zcl_box_path,
*          lr_target type ref to zcl_boxed_data.
*
*    result = binding-&gt;get_target( ).
*
*    loop at binding-&gt;_map_tab into data(ls_map).
*      split ls_map-path at &apos;:&apos; into table lt_split.
*
*      data(lv_count) = lines( lt_split ).
*      if lv_count lt 1 or lv_count gt 2.
*        &quot;... ERROR
*      endif.
*
*      case lv_count.
*        when 1. &quot;... To Target
*          lr_source = me.
*
*          lr_tgt_path = new zcl_box_path( lt_split[ 1 ] ).
*          lr_target = lr_tgt_path-&gt;resolve( binding-&gt;get_target( ) ).
*        when 2. &quot;... Source to Target
*          lr_src_path = new zcl_box_path( lt_split[ 1 ] ).
*          lr_source = lr_src_path-&gt;resolve( me ).
*
*          lr_tgt_path = new zcl_box_path( lt_split[ 2 ] ).
*          lr_target = lr_tgt_path-&gt;resolve( binding-&gt;get_target( ) ).
*      endcase.
*
*      if lr_source is initial or lr_target is initial.
*        &quot;... ANOTHER ERROR!~
*      endif.
*
*      if ls_map-conformer is not initial.
*        if ls_map-conformer-&gt;validate( lr_source ) eq abap_false.
*          &quot;... VALIDATION ERROR
*        endif.
*
*        lr_source = ls_map-conformer-&gt;transform( lr_source ).
*      endif.
*
*      data(lr_data) = lr_source-&gt;get_data( ).
*      assign lr_data-&gt;* to field-symbol(&lt;fs_value&gt;).
*
*      &quot;... Set the target value
*      lr_target-&gt;set_value( &lt;fs_value&gt; ).
*
*      case binding_mode.
*        when 1.
*          add_binding( source_path = lr_src_path-&gt;get_path( )
*                       target = lr_target
*                       conformer = ls_map-conformer ).
*        when 2.
*          add_binding( source_path = lr_src_path-&gt;get_path( )
*                       target = lr_target
*                       conformer = ls_map-conformer ).
*          binding-&gt;get_target( )-&gt;add_binding( source_path = lr_tgt_path-&gt;get_path( )
*                                               target = lr_source
*                                               conformer = ls_map-conformer ).
*      endcase.
*    endloop.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="CHECK_TYPE_MATCH" VERSION="1" LANGU="E" DESCRIPT="Check that a type for mapping matches" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="CHECK_TYPE_MATCH" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method check_type_match.
  data: lr_box type ref to zcl_boxed_data,
      lv_text type string.
  lr_box = zcl_boxed_packer=&gt;box( value ).

  if lr_box-&gt;boxed_type ne boxed_type.
    lv_text = |The provided value type [{ lr_box-&gt;get_abap_type( ) }] |.
    lv_text = |{ lv_text }doesnt match the stored value [{ get_abap_type( ) }] for assignment|.
    raise exception type zcx_boxed_value_mismatch
      exporting
        text = lv_text.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="CONSTRUCTOR" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <source>method constructor.
    &quot;===============================================
    &quot; The input is copied into an internal reference
    &quot; it is impossible to otherwise use the original
    &quot; variable as it is partially protected against
    &quot; changes when passed into an object. The outcome
    &quot; of all this is that the original passed value wont
    &quot; ever be modified by modifying the object. Which
    &quot; is a little unfortunate in this rare circumstance
    &quot;===============================================
    field-symbols: &lt;fs_input&gt; type any.

    &quot;... Create the internal data
    create data data like value.

    &quot;... Assign the contents of the newly created data
    assign data-&gt;* to &lt;fs_input&gt;.

    &quot;... Set the contents to the value of the input
    &lt;fs_input&gt; = value.

    if type_descr is not initial.
      me-&gt;type_descr = type_descr.
    else.
      me-&gt;type_descr = cl_abap_typedescr=&gt;describe_by_data( p_data = value ).
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="COPY" VERSION="1" LANGU="E" DESCRIPT="Returns a copy of this object" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="COPY" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method copy.
    field-symbols: &lt;fs_result&gt; type any,
                   &lt;fs_data&gt; type any.

    &quot;... Assign the data in the object to a a FS
    assign me-&gt;data-&gt;* to &lt;fs_data&gt;.

    &quot;... Create the copy
    result = zcl_boxed_packer=&gt;box( &lt;fs_data&gt; ).

    result-&gt;bindings = me-&gt;bindings.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="EQUALS" VERSION="1" LANGU="E" DESCRIPT="Check for value equivalence takes value or boxed" EXPOSURE="2" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="EQUALS" SCONAME="ANY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="EQUALS" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method equals.
  data: lr_boxed type ref to zcl_boxed_data.
  field-symbols: &lt;fs_source&gt; type any,
                 &lt;fs_target&gt; type any.

  try.
      lr_boxed = any.
    catch cx_root.
  endtry.

  assign me-&gt;data-&gt;* to &lt;fs_source&gt;.

  if lr_boxed is not initial.
    assign lr_boxed-&gt;data-&gt;* to &lt;fs_target&gt;.

    check sy-subrc eq 0.
    if &lt;fs_source&gt; eq &lt;fs_target&gt;.
      result = abap_true.
    endif.
  else.
    if any eq &lt;fs_source&gt;.
      result = abap_true.
    endif.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_ABAP_TYPE" VERSION="1" LANGU="E" DESCRIPT="Get the ABAP type for use in error messages" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_ABAP_TYPE" SCONAME="DESCR" VERSION="1" LANGU="E" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_ABAP_TYPE" SCONAME="TYPE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method get_abap_type.
    data: lr_descr type ref to cl_abap_typedescr.

    if descr is not initial.
      lr_descr = descr.
    else.
      lr_descr = type_descr.
    endif.
    type = lr_descr-&gt;get_relative_name( ).

    if type is initial.
      type = lr_descr-&gt;type_kind.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_DATA" VERSION="1" LANGU="E" DESCRIPT="Gets the boxed value as a data reference" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_DATA" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>method get_data.
    field-symbols: &lt;fs_result&gt; type any,
                   &lt;fs_data&gt; type any.

    &quot;... Return the exact reference
    data = me-&gt;data.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_DESCRIPTOR" VERSION="1" LANGU="E" DESCRIPT="Get the corresponding ABAP descriptor object" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_DESCRIPTOR" SCONAME="DESCR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <source>method get_descriptor.
    descr = me-&gt;type_descr.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_VALUE" VERSION="1" LANGU="E" DESCRIPT="Gets the boxed value" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="GET_VALUE" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method get_value.
    field-symbols: &lt;fs_data&gt; type any.

    &quot;... Assign the data in the object to a a FS
    assign data-&gt;* to &lt;fs_data&gt;.

    &quot;... Check the type can match (as best as possible)
    check_type_match( value ).

    &quot;... Assign the value
    value = &lt;fs_data&gt;.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="HAS_BINDINGS" VERSION="1" LANGU="E" DESCRIPT="Returns true if any bindings are set" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="HAS_BINDINGS" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method has_bindings.
    read table bindings with key source_path = &apos;&apos; transporting no fields.

    if sy-subrc eq 0.
      result = abap_true.
    else.
      result = abap_false.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="IS_INITIAL" VERSION="1" LANGU="E" DESCRIPT="Check if value is initial" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="IS_INITIAL" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method is_initial.
  field-symbols: &lt;fs_data&gt; type any.
  assign data-&gt;* to &lt;fs_data&gt;.

  if &lt;fs_data&gt; is initial.
    result = abap_true.
  else.
    result = abap_false.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="MAP" VERSION="1" LANGU="E" DESCRIPT="Maps a target mapping returning the result for convenience" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="MAP" SCONAME="MAPPING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_MAPPING"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="MAP" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOXED_DATA" CMPNAME="MAP" SCONAME="ZCX_BOX_PATH_INVALID_FORMAT" VERSION="1" LANGU="E" DESCRIPT="Box Path Invalid Format Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>method map.
* DEACTIVATED FOR 7.0
  data: lt_split type standard table of string,
        lv_split type string,
        lr_source type ref to zcl_boxed_data,
        lv_text type string,
        lr_path type ref to zcl_box_path,
        lr_target type ref to zcl_boxed_data.

  result = mapping-&gt;get_target( ).

  data: ls_map like line of mapping-&gt;_map_tab.
  loop at mapping-&gt;_map_tab into ls_map.
    split ls_map-path at &apos;:&apos; into table lt_split.

    data: lv_count type i.
    lv_count = lines( lt_split ).
    if lv_count lt 1 or lv_count gt 2.
      concatenate &apos;the mapping path &apos; ls_map-path &apos; is not valid&apos; into lv_text.
      concatenate lv_text `it should be &apos;source_boxed-path:target_boxed-path&apos;` into lv_text.

      raise exception type zcx_box_path_invalid_format
        exporting
          text = lv_text.
    endif.

    data: lr_tgt type ref to zcl_boxed_data.
    case lv_count.
      when 1. &quot;... To Target
        lr_source = me.
        read table lt_split index 1 into lv_split.
        create object lr_path
          exporting
            path = lv_split.
        lr_tgt = mapping-&gt;get_target( ).
        lr_target = lr_path-&gt;resolve( lr_tgt ).
      when 2. &quot;... Source to Target
        read table lt_split index 1 into lv_split.
        create object lr_path
          exporting
            path = lv_split.
        lr_source = lr_path-&gt;resolve( me ).

        read table lt_split index 2 into lv_split.
        create object lr_path
          exporting
            path = lv_split.
        lr_tgt = mapping-&gt;get_target( ).
        lr_target = lr_target = lr_path-&gt;resolve( lr_tgt ).
    endcase.

    if lr_source is initial or lr_target is initial.
      if lr_source is initial.
        concatenate &apos;the mapping path &apos; ls_map-path &apos; is not valid&apos; into lv_text.
        concatenate lv_text `it should be &apos;source_boxed-path:target_boxed-path&apos;` into lv_text.
      else.

      endif.
      raise exception type zcx_boxed_mapping_exception
        exporting
          text = lv_text.
    endif.

    if ls_map-conformer is not initial.
      if ls_map-conformer-&gt;validate( lr_source ) eq abap_false.
        &quot;... VALIDATION ERROR
      endif.

      lr_source = ls_map-conformer-&gt;transform( lr_source ).
    endif.

    data: lr_data type ref to data.
    field-symbols &lt;fs_value&gt; type any.
    lr_data = lr_source-&gt;get_data( ).
    assign lr_data-&gt;* to &lt;fs_value&gt;.

    &quot;... Set the target value
    lr_target-&gt;set_value( &lt;fs_value&gt; ).
  endloop.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="RESOLVE_PATH" VERSION="1" LANGU="E" DESCRIPT="Returns a boxed value from navigable complex types" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="RESOLVE_PATH" SCONAME="PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="RESOLVE_PATH" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOXED_DATA" CMPNAME="RESOLVE_PATH" SCONAME="ZCX_BOX_PATH_INVALID_FORMAT" VERSION="1" LANGU="E" DESCRIPT="Box Path Invalid Format Exception" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_BOXED_DATA" CMPNAME="RESOLVE_PATH" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" DESCRIPT="Box Path Dynamic Where Condition Failure Exception (ABAP)" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_BOXED_DATA" CMPNAME="RESOLVE_PATH" SCONAME="ZCX_BOX_PATH_TYPE_NOT_NAVIG" VERSION="1" LANGU="E" DESCRIPT="Box Path Data Type Not Navigable Exception" MTDTYPE="0" EDITORDER="3 "/>
   <source>method resolve_path.
  data: lr_path type ref to zcl_box_path,
        lv_path type string.

  create object lr_path
    exporting
      path = path.

  result = lr_path-&gt;resolve( me ).

  &quot;... Transfers any bindings relevant for the resolved data
  lv_path = lr_path-&gt;get_path( ).

  transfer_bindings( path = lv_path  boxed_data = result ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="SERIALIZE" VERSION="1" LANGU="E" DESCRIPT="Serializes the data" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="SERIALIZE" SCONAME="STREAM_TYPE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="IF_SXML=&gt;XML_STREAM_TYPE"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="SERIALIZE" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSTRING"/>
   <source>method serialize.
  data: writer type ref to cl_sxml_string_writer.
  field-symbols: &lt;fs_data&gt; type any.

  &quot;... Assign the data in the object to a FS
  assign data-&gt;* to &lt;fs_data&gt;.

  writer  = cl_sxml_string_writer=&gt;create( stream_type ).
  call transformation id source data = &lt;fs_data&gt;
                         result xml writer.
  result = writer-&gt;get_output( ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="SET_VALUE" VERSION="1" LANGU="E" DESCRIPT="Sets the boxed value" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="SET_VALUE" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method set_value.
    field-symbols: &lt;fs_data&gt; type any.

    &quot;... Assign the data in the object to a a FS
    assign data-&gt;* to &lt;fs_data&gt;.

    &quot;... Check the type can match (as best as possible)
    check_type_match( value ).

    &quot;... Set the value
    &lt;fs_data&gt; = value.

    &quot;... Handle any bindings
    update_bindings( value ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_JSON" VERSION="1" LANGU="E" DESCRIPT="Serialize the data to JSON string" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_JSON" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method to_json.
  &quot;... NOT AVAILABLE IN 7.2
*    result = cl_abap_codepage=&gt;convert_from( serialize( if_sxml=&gt;co_xt_json ) ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_STRING" VERSION="1" LANGU="E" DESCRIPT="Returns a string representation of the value" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_STRING" SCONAME="STR_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method to_string.
    field-symbols: &lt;fs_data&gt; type any.
    assign data-&gt;* to &lt;fs_data&gt;.
    str_value = &lt;fs_data&gt;.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_XML" VERSION="1" LANGU="E" DESCRIPT="Serialize the data to XML string" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_XML" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method to_xml.
    result = cl_abap_codepage=&gt;convert_from( serialize( if_sxml=&gt;co_xt_xml10 ) ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_XSTRING" VERSION="1" LANGU="E" DESCRIPT="Returns data as XString" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_XSTRING" SCONAME="STREAM_TYPE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="IF_SXML=&gt;XML_STREAM_TYPE" PARVALUE="IF_SXML=&gt;CO_XT_XML10"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="TO_XSTRING" SCONAME="XSTR_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSTRING"/>
   <source>method TO_XSTRING.
    xstr_value = serialize( stream_type ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="TRANSFER_BINDINGS" VERSION="1" LANGU="E" DESCRIPT="Transfer binds to a resolved boxed data" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="TRANSFER_BINDINGS" SCONAME="PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="TRANSFER_BINDINGS" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method transfer_bindings.
  data: ls_binding type binding_struct.
  if bindings is not initial.
    loop at bindings into ls_binding where source_path cp |{ path }*|.
      boxed_data-&gt;add_binding( target = ls_binding-target
                               source_path = substring_after( val = ls_binding-source_path sub = path )
                               conformer   = ls_binding-conformer ).
    endloop.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_DATA" CMPNAME="UPDATE_BINDINGS" VERSION="1" LANGU="E" DESCRIPT="Updates any bindings for this data" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA" CMPNAME="UPDATE_BINDINGS" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method update_bindings.
  data: ls_binding like line of bindings,
        lr_data type ref to data.
  field-symbols:&lt;fs_data&gt; type any.
  loop at bindings into ls_binding where source_path is initial.
    lr_data = ls_binding-target-&gt;get_data( ).
    assign lr_data-&gt;* to &lt;fs_data&gt;.

    &quot;... Check the type
    ls_binding-target-&gt;check_type_match( &lt;fs_data&gt; ).

    &quot;... Set the value
    &lt;fs_data&gt; = value.
  endloop.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_TYPE_MISMATCH" VERSION="1" LANGU="E" DESCRIPT="Boxed Type Mismatch Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_DATA_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_TYPE_MISMATCH" CMPNAME="ZCX_BOXED_TYPE_MISMATCH" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_TYPE_MISMATCH" REFCLSNAME="ZCX_BOXED_DATA_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_DATA_UTIL" VERSION="1" LANGU="E" DESCRIPT="Performs some util functions used by the framework" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <method CLSNAME="ZCL_BOXED_DATA_UTIL" CMPNAME="REPLACE_STREXP_WITH_QUOTE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_DATA_UTIL" CMPNAME="REPLACE_STREXP_WITH_QUOTE" SCONAME="SOURCE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_DATA_UTIL" CMPNAME="REPLACE_STREXP_WITH_QUOTE" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method REPLACE_STREXP_WITH_QUOTE.
     result = replace( val = source regex = `(\|)([\s\w][^|]*)(\|)` with = `&apos;$2&apos;` ).
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOX_PATH_INVALID_FORMAT" VERSION="1" LANGU="E" DESCRIPT="Box Path Invalid Format Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOX_PATH_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOX_PATH_INVALID_FORMAT" CMPNAME="ZCX_BOX_PATH_INVALID_FORMAT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOX_PATH_INVALID_FORMAT" REFCLSNAME="ZCX_BOX_PATH_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_REF" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Ref (e.g. ref to Data)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCL_BOXED_DATA">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCL_BOXED_REF" REFCLSNAME="ZCL_BOXED_DATA" VERSION="1" STATE="1"/>
  <method CLSNAME="ZCL_BOXED_REF" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_REF" CMPNAME="CONSTRUCTOR" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_REF" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Dont use this, its for the factory performance" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <source>method constructor.
    data: input type ref to data,
          data type ref to data,
          lr_descr type ref to cl_abap_typedescr.
    field-symbols: &lt;fs_input&gt; type any,
                   &lt;fs_data&gt; type any.

    &quot;... Get the type descr to handle errors early
    lr_descr = cl_abap_typedescr=&gt;describe_by_data( p_data = value ).

    super-&gt;constructor( value = value type_descr = lr_descr ).

    boxed_type = zcl_boxed_packer=&gt;co_type_ref.

    me-&gt;type_descr = lr_descr.

    if lr_descr-&gt;kind ne cl_abap_typedescr=&gt;kind_ref.
      data: lv_text type string.
      lv_text = |The abap type [{ get_abap_type( ) }] does not match the boxed type [{ boxed_type }]|.
      raise exception type zcx_boxed_type_mismatch
        exporting
          text = lv_text.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_REF" CMPNAME="TO_SOURCE" VERSION="1" LANGU="E" DESCRIPT="Returns the underlying source as a boxed type" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_REF" CMPNAME="TO_SOURCE" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method TO_SOURCE.
    data: lr_source type ref to data.
    field-symbols: &lt;fs_data&gt; type any,
                   &lt;fs_source&gt; type any.

    assign data-&gt;* to &lt;fs_data&gt;. &quot;... Boxed data
    assign &lt;fs_data&gt;-&gt;* to &lt;fs_source&gt;. &quot;... Original contents of data ref

    &quot;... Get the boxed type
    boxed_data = zcl_boxed_packer=&gt;box( &lt;fs_source&gt; ).

    &quot;... Override the data with the actual data ref source
    &quot;... so that the resolve Returns the true value
    boxed_data-&gt;data = &lt;fs_data&gt;.
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_TABLESET" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Table (a Table Type)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCL_BOXED_COMPLEX_TYPE">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_standard_iterator definition.
  public section.
    interfaces zif_boxed_iterator.
    methods constructor
      importing
        boxed_table type ref to zcl_boxed_tableset.
  protected section.
  private section.
    data: _boxed_table type ref to zcl_boxed_tableset,
          _size type i,
          _index type i.
endclass.
class lcl_standard_iterator implementation.
  method constructor.
    _boxed_table = boxed_table.
    _size = _boxed_table-&gt;size( ).
    _index = 1.
  endmethod.
  method zif_boxed_iterator~has_next.
    if _index le _size.
      result = abap_true.
    else.
      result = abap_false.
    endif.
  endmethod.
  method zif_boxed_iterator~next.
    boxed_data = _boxed_table-&gt;find_with_index( _index ).
    _index = _index + 1.
  endmethod.
endclass.
class lcl_complex_iterator definition.
  public section.
    interfaces zif_boxed_iterator.
    methods constructor
      importing
        boxed_table type ref to zcl_boxed_tableset.
  protected section.
  private section.
    data: boxed_table type ref to zcl_boxed_tableset.
    data: iteration_table type ref to zcl_boxed_tableset.
    data: current type ref to zcl_boxed_data.
    methods get_next
      returning
        value(next) type ref to zcl_boxed_data.
endclass.
class lcl_complex_iterator implementation.
  method constructor.
    &quot;... Set the main boxed table, elements are pulled from it
    me-&gt;boxed_table = boxed_table.

    &quot;... Due to the generic data and field symbols and index read will be impossible
    &quot;... To counter we will create a copy here, to remove items as we go which
    &quot;... while space intensive will be less time consuming
    me-&gt;iteration_table ?= boxed_table-&gt;copy( ).

    &quot;... Set the current item
    current = get_next( ).
  endmethod.
  method zif_boxed_iterator~has_next.
    if iteration_table-&gt;size( ) eq 0.
      result = abap_false.
    else.
      result = abap_true.
    endif.
  endmethod.
  method zif_boxed_iterator~next.
    &quot;... Return the current item or index
    boxed_data = current.

    &quot;... Remove the indexed item
    iteration_table-&gt;remove( current ).

    &quot;... Set the next current
    current = get_next( ).
  endmethod.
  method get_next.
    data: lr_table type ref to data.
    field-symbols: &lt;fs_tab&gt; type any table,
                   &lt;fs_line&gt; type any.

    lr_table = iteration_table-&gt;get_data( ).
    assign lr_table-&gt;* to &lt;fs_tab&gt;.

    loop at &lt;fs_tab&gt; assigning &lt;fs_line&gt;.
      next = zcl_boxed_packer=&gt;box( &lt;fs_line&gt; ).
      exit.
    endloop.

    &quot;... This abstract looking section ensures that the actual
    &quot;... memory reference from the table is returned
    if next is not initial.
      next = boxed_table-&gt;get_element( next ).
    endif.
  endmethod.
endclass.</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section
class lcl_standard_iterator definition deferred.
class lcl_complex_iterator definition deferred.
class zcl_boxed_tableset definition local friends: lcl_standard_iterator, lcl_complex_iterator.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="LINE_TYPE_DESCR" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_BOXED_TABLESET" REFCLSNAME="ZCL_BOXED_COMPLEX_TYPE" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_BOXED_TABLESET" REFCLSNAME="ZCL_BOXED_COMPLEX_TYPE" VERSION="1" MTDNAME="TO_STRING" EXPOSURE="2"/>
  </inheritance>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="CLEAR" VERSION="1" LANGU="E" DESCRIPT="Remove all elements from this set" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method clear.
    field-symbols: &lt;fs_data&gt; type any table.
    assign data-&gt;* to &lt;fs_data&gt;.
    clear &lt;fs_data&gt;.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="CONSTRUCTOR" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="CONSTRUCTOR" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" DESCRIPT="Dont use this, its for the factory performance" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <source>method constructor.
    super-&gt;constructor( value = value type_descr = type_descr ).

    boxed_type = zcl_boxed_packer=&gt;co_type_tableset.

    &quot;... Set the line type descr
    line_type_descr = get_line_type_descr( ).

    if me-&gt;type_descr-&gt;kind ne cl_abap_typedescr=&gt;kind_table.
      data: lv_text type string.
      lv_text = |The abap type [{ get_abap_type( ) }] does not match the boxed type [{ boxed_type }]|.
      raise exception type zcx_boxed_type_mismatch
        exporting
          text = lv_text.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND" VERSION="1" LANGU="E" DESCRIPT="Find the FIRST boxed data matching the dyn where condition" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND" SCONAME="WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND" SCONAME="ZCX_BOXED_TABLE_INDEX_NOT_SUPP" VERSION="1" LANGU="E" DESCRIPT="Boxed Table Index Not Supported Exception" MTDTYPE="0" EDITORDER="2 "/>
   <source>method find.
  data: lv_where type string,
        lv_index type i,
        lr_descr type ref to cl_abap_tabledescr.

  &quot;... Get the where and index
  get_condition( exporting input = where
                 importing where = lv_where
                           index = lv_index ).
  lr_descr ?= type_descr.
  if lr_descr-&gt;table_kind eq cl_abap_tabledescr=&gt;tablekind_std and lv_index is not initial.
    boxed_data = find_with_index( lv_index ).
  else.
    if lv_index is not initial.
      raise exception type zcx_boxed_table_index_not_supp
        exporting
          text = |Index access is not supported for table type { get_abap_type( ) }|.
    endif.

    &quot;... Find with no index
    boxed_data = find_without_index( lv_where ).
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL" VERSION="1" LANGU="E" DESCRIPT="Find ALL boxed data matching the dyn where condition" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL" SCONAME="WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL" SCONAME="BOXED_TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_TABLESET"/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL" SCONAME="ZCX_BOXED_TABLE_INDEX_NOT_SUPP" VERSION="1" LANGU="E" DESCRIPT="Boxed Table Index Not Supported Exception" MTDTYPE="0" EDITORDER="2 "/>
   <source>method find_all.
  data: lv_where type string,
        lv_index type i,
        lr_descr type ref to cl_abap_tabledescr.

  &quot;... Get the where and index
  get_condition( exporting input = where
                 importing where = lv_where
                           index = lv_index ).

  lr_descr ?= get_descriptor( ).
  if lr_descr-&gt;table_kind eq cl_abap_tabledescr=&gt;tablekind_std and lv_index is not initial.
    boxed_table = find_all_with_index( lv_index ).
  else.
    if lv_index is not initial.
      raise exception type zcx_boxed_table_index_not_supp
        exporting
          text = |Index access is not supported for table type { get_abap_type( ) }|.
    endif.

    &quot;... Find with no index
    boxed_table = find_all_without_index( lv_where ).
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITHOUT_INDEX" VERSION="1" LANGU="E" DESCRIPT="Uses underlying table to find all items" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITHOUT_INDEX" SCONAME="WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITHOUT_INDEX" SCONAME="BOXED_TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_TABLESET"/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITHOUT_INDEX" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method find_all_without_index.
  data: lr_results type ref to data.
  field-symbols: &lt;fs_table&gt; type any table,
                 &lt;fs_results&gt; type any table,
                 &lt;fs_line&gt; type any.

  assign data-&gt;* to &lt;fs_table&gt;.
  create data lr_results like &lt;fs_table&gt;.
  assign lr_results-&gt;* to &lt;fs_results&gt;.

  try.
      loop at &lt;fs_table&gt;  assigning &lt;fs_line&gt; where (where).
        insert &lt;fs_line&gt; into table &lt;fs_results&gt;.
      endloop.
    catch cx_sy_itab_dyn_loop.
      data: lv_text type string.
      lv_text = |The dynamic where clause [{ where }] failed during iteration of table type [{ get_abap_type( ) }]|.
      raise exception type zcx_box_path_dyn_cond_fail
        exporting
          text = lv_text.
  endtry.

  &quot;... Create the return which is a copy
  create object boxed_table
    exporting
      value = &lt;fs_results&gt;.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITH_INDEX" VERSION="1" LANGU="E" DESCRIPT="Uses standard table to find all items" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITH_INDEX" SCONAME="INDEX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITH_INDEX" SCONAME="BOXED_TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_TABLESET"/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_ALL_WITH_INDEX" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method find_all_with_index.
  data: lr_results type ref to data.
  field-symbols: &lt;fs_table&gt; type standard table,
                 &lt;fs_results&gt; type standard table,
                 &lt;fs_line&gt; type any.

  assign data-&gt;* to &lt;fs_table&gt;.
  create data lr_results like &lt;fs_table&gt;.
  assign lr_results-&gt;* to &lt;fs_results&gt;.

  read table &lt;fs_table&gt; index index assigning &lt;fs_line&gt;.

  insert &lt;fs_line&gt; into table &lt;fs_results&gt;.

  &quot;... Create the return which is a copy
  create object boxed_table
    exporting
      value = &lt;fs_results&gt;.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITHOUT_INDEX" VERSION="1" LANGU="E" DESCRIPT="Uses underlying table to find first item" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITHOUT_INDEX" SCONAME="WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITHOUT_INDEX" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITHOUT_INDEX" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method find_without_index.
    field-symbols: &lt;fs_table&gt; type any table,
                   &lt;fs_line&gt; type any.

    assign data-&gt;* to &lt;fs_table&gt;.

    try.
        loop at &lt;fs_table&gt; assigning &lt;fs_line&gt; where (where).
          &quot;... Pack the box
          boxed_data = zcl_boxed_packer=&gt;internal_box( value = &lt;fs_line&gt; type_descr = line_type_descr ).

          &quot;... Replace the copied reference
          get reference of &lt;fs_line&gt; into boxed_data-&gt;data.
          exit. &quot;... Exit if found
        endloop.
      catch cx_sy_itab_dyn_loop.
        data: lv_text type string.
        lv_text = |The dynamic conditional clause [{ where }] failed during iteration of table type [{ get_abap_type( ) }]|.
        raise exception type zcx_box_path_dyn_cond_fail
          exporting
            text = lv_text.
    endtry.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITH_INDEX" VERSION="1" LANGU="E" DESCRIPT="Uses standard table to find first item" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITH_INDEX" SCONAME="INDEX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITH_INDEX" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <exception CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIND_WITH_INDEX" SCONAME="ZCX_BOX_PATH_DYN_COND_FAIL" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method find_with_index.
    field-symbols: &lt;fs_table&gt; type standard table,
                   &lt;fs_line&gt; type any.

    assign data-&gt;* to &lt;fs_table&gt;.

    read table &lt;fs_table&gt; index index assigning &lt;fs_line&gt;.

    &quot;... If not found no result returned
    check sy-subrc eq 0.

    &quot;... Pack the box
    boxed_data = zcl_boxed_packer=&gt;internal_box( value = &lt;fs_line&gt; type_descr = line_type_descr ).

    &quot;... Replace the copied reference
    get reference of &lt;fs_line&gt; into boxed_data-&gt;data.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIRST" VERSION="1" LANGU="E" DESCRIPT="Gets the first boxed data in the set" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="FIRST" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method FIRST.
    boxed_data = find( &apos;1&apos; ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_CONDITION" VERSION="1" LANGU="E" DESCRIPT="Extracts condition info" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_CONDITION" SCONAME="INPUT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_CONDITION" SCONAME="INDEX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_CONDITION" SCONAME="WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>method get_condition.
  data: cond type string.
  data: lv_regex_i type string value `^ *\[? *(\d+) *\]? *$`,
        lv_regex_w type string value `(\|)([\s\w][^|]*)(\|)`.

  cond = input.

  if contains( val = cond regex = lv_regex_i ).
    index = replace( val = cond regex = lv_regex_i with = `$1` ).
  else.
    &quot;... Trim square brackets
    if cond(1) eq &apos;[&apos;.
      data len type i.
      len = strlen( input ).
      cond = substring( val = cond off = 1 len = len - 2 ).
    endif.

    &quot;... Replace &apos;|&apos; fields
    where = replace( val = cond regex = lv_regex_w occ = 0 with = `&apos;$2&apos;` ).
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_ELEMENT" VERSION="1" LANGU="E" DESCRIPT="Get an actual element" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_ELEMENT" SCONAME="ELEMENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_ELEMENT" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method get_element.
    data: lr_line type ref to data,
          lr_input type ref to data.
    field-symbols: &lt;fs_table&gt; type any table,
                   &lt;fs_input&gt; type any,
                   &lt;fs_result&gt; type any,
                   &lt;fs_line&gt; type any.

    assign data-&gt;* to &lt;fs_table&gt;.

    lr_input = element-&gt;get_data( ).
    assign lr_input-&gt;* to &lt;fs_input&gt;.

    read table &lt;fs_table&gt; from &lt;fs_input&gt; assigning &lt;fs_result&gt;.
    boxed_data = zcl_boxed_packer=&gt;internal_box( value = &lt;fs_result&gt; type_descr = line_type_descr ).

    &quot;... Ensure its the actual reference returned
    get reference of &lt;fs_result&gt; into boxed_data-&gt;data.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_LINE" VERSION="1" LANGU="E" DESCRIPT="Returns an empty line as boxed data" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_LINE" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method get_line.
    data: lr_line type ref to data.
    field-symbols: &lt;fs_table&gt; type any table,
                   &lt;fs_input&gt; type any,
                   &lt;fs_line&gt; type any.

    assign data-&gt;* to &lt;fs_table&gt;.
    create data lr_line like line of &lt;fs_table&gt;.
    assign lr_line-&gt;* to &lt;fs_line&gt;.
    boxed_data = zcl_boxed_packer=&gt;internal_box( value = &lt;fs_line&gt; type_descr = line_type_descr ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_LINE_TYPE_DESCR" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="GET_LINE_TYPE_DESCR" SCONAME="DESCR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <source>method GET_LINE_TYPE_DESCR.
    data: lr_line type ref to data.
    field-symbols: &lt;fs_table&gt; type any table,
                   &lt;fs_input&gt; type any,
                   &lt;fs_line&gt; type any.

    assign data-&gt;* to &lt;fs_table&gt;.
    create data lr_line like line of &lt;fs_table&gt;.
    assign lr_line-&gt;* to &lt;fs_line&gt;.
    descr = cl_abap_typedescr=&gt;describe_by_data( &lt;fs_line&gt; ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="INDEX_REGEX" VERSION="1" LANGU="E" DESCRIPT="Method is required due to escaped characters in regex" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="INDEX_REGEX" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method index_regex.

    data: regex1 type string,
          regex2 type string.

    &quot;...this regex has been broken up because of escaped characters.
    &quot;...the regex will match a combination of characters/digits which contain an operator up
    &quot;...to the point of a | or &apos; or space/digit (space digit is considered the start of index
    &quot;...criteria.

    regex1 = &apos;(^.*(=|[a-zA-Z]|&gt;|&lt;).(.+\||.+&apos;.
    regex1 = |{ regex1 }&apos;|.
    regex2 = &apos;|\d*\S))&apos;.

    concatenate regex1 regex2 into result.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="INSERT" VERSION="1" LANGU="E" DESCRIPT="Insert the boxed data or value into the set" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="INSERT" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method insert.
  data: boxed_data type ref to zcl_boxed_data,
        lr_input type ref to data.

  field-symbols: &lt;fs_input&gt; type any.

  try.
      boxed_data ?= data.
      lr_input = boxed_data-&gt;get_data( ).
      assign lr_input-&gt;* to &lt;fs_input&gt;.

      &quot;... Insert the value
      insert_value( &lt;fs_input&gt; ).
    catch cx_sy_move_cast_error.
      &quot;... Insert the initial input
      insert_value( data ).
  endtry.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="INSERT_VALUE" VERSION="1" LANGU="E" DESCRIPT="Insert the value into the set (depending on table type)" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="INSERT_VALUE" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method insert_value.
    data: lr_line type ref to data.
    field-symbols: &lt;fs_table&gt; type any table,
                   &lt;fs_input&gt; type any,
                   &lt;fs_line&gt; type any.

    assign data-&gt;* to &lt;fs_table&gt;.
    create data lr_line like line of &lt;fs_table&gt;.
    assign lr_line-&gt;* to &lt;fs_line&gt;.

    &lt;fs_line&gt; = value.

    insert &lt;fs_line&gt; into table &lt;fs_table&gt;.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="IS_EMPTY" VERSION="1" LANGU="E" DESCRIPT="Returns true if this collection has no elements" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="IS_EMPTY" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method is_empty.
    if size( ) le 0.
      result = abap_true.
    else.
      result = abap_false.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="ITERATOR" VERSION="1" LANGU="E" DESCRIPT="Return an iterator over this set of elements" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="ITERATOR" SCONAME="ITERATOR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_BOXED_ITERATOR"/>
   <source>method iterator.
  data: lr_descr type ref to cl_abap_tabledescr.

  lr_descr ?= get_descriptor( ).

  case lr_descr-&gt;table_kind.
    when cl_abap_tabledescr=&gt;tablekind_std.
      create object iterator
        type
        (&apos;LCL_STANDARD_ITERATOR&apos;)
        exporting
          boxed_table = me.
*        iterator = new lcl_standard_iterator( me ).
    when others.
      create object iterator
        type
        (&apos;LCL_COMPLEX_ITERATOR&apos;)
        exporting
          boxed_table = me.
*      iterator = new lcl_complex_iterator( me ).
  endcase.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="LAST" VERSION="1" LANGU="E" DESCRIPT="Gets the last boxed data in the set" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="LAST" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method LAST.
    boxed_data = find( |{ size( ) - 1 }| ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="REMOVE" VERSION="1" LANGU="E" DESCRIPT="Remove the supplied boxed data or value" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="REMOVE" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method remove.
  data: boxed_data type ref to zcl_boxed_data,
        lr_input type ref to data.
  field-symbols: &lt;fs_input&gt; type any.

  try.
      boxed_data ?= data.
      lr_input = boxed_data-&gt;get_data( ).
      assign lr_input-&gt;* to &lt;fs_input&gt;.

      &quot;... Remove the value
      remove_value( &lt;fs_input&gt; ).
    catch cx_sy_move_cast_error.
      &quot;... Remove the initial input
      remove_value( data ).
  endtry.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="REMOVE_VALUE" VERSION="1" LANGU="E" DESCRIPT="Remove the supplied value" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="REMOVE_VALUE" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method remove_value.
    data: lr_line type ref to data.
    field-symbols: &lt;fs_table&gt; type any table,
                   &lt;fs_line&gt; type any.

    assign data-&gt;* to &lt;fs_table&gt;.
    create data lr_line like line of &lt;fs_table&gt;.
    assign lr_line-&gt;* to &lt;fs_line&gt;.

    &lt;fs_line&gt; = value.

    delete table &lt;fs_table&gt; from &lt;fs_line&gt;.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="SIZE" VERSION="1" LANGU="E" DESCRIPT="Return the number of elements" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="SIZE" SCONAME="SIZE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method size.
    field-symbols: &lt;fs_data&gt; type any table.
    assign data-&gt;* to &lt;fs_data&gt;.

    size = lines( &lt;fs_data&gt; ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="SORT" VERSION="1" LANGU="E" DESCRIPT="Sorts the table by field e.g. &apos;table_line:descending&apos;" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_TABLESET" CMPNAME="SORT" SCONAME="BY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>method sort.
  data: lt_sort type abap_sortorder_tab,
        ls_sort type line of abap_sortorder_tab,
        lt_fields type standard table of string,
        ls_field type string,
        field type string,
        direction type string.

  &quot;... Get the table out
  field-symbols: &lt;fs_tab&gt; type any table.
  assign data-&gt;* to &lt;fs_tab&gt;.

  split by at &apos;,&apos; into table lt_fields.

  loop at lt_fields into ls_field.
    split ls_field at &apos;:&apos; into field direction.

    ls_sort-name = field.
    case direction.
      when &apos;descending&apos;.
        ls_sort-descending = abap_true.
    endcase.

    append ls_sort to lt_sort.
  endloop.

  sort &lt;fs_tab&gt; by (lt_sort).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_COMPLEX_TYPE" CMPNAME="TO_STRING" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method to_string.
  data: lr_it type ref to zif_boxed_iterator,
        lr_element type ref to zcl_boxed_data.
  lr_it = iterator( ).

  while lr_it-&gt;has_next( ) eq abap_true.
    lr_element = lr_it-&gt;next( ).

    if str_value is not initial.
      str_value = |{ str_value }{ cl_abap_char_utilities=&gt;cr_lf }|.
    endif.

    if lr_element-&gt;boxed_type eq zcl_boxed_packer=&gt;co_type_struct.
      str_value = |{ str_value }{ lr_element-&gt;to_string( ) }{ cl_abap_char_utilities=&gt;cr_lf }|.
    else.
      str_value = |{ str_value }{ lr_element-&gt;to_string( ) }|.
    endif.
  endwhile.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_MAPPING_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Mapping Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_MAPPING_EXCEPTION" CMPNAME="ZCX_BOXED_MAPPING_EXCEPTION" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_MAPPING_EXCEPTION" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_COMPLEX_TYPE" VERSION="1" LANGU="E" DESCRIPT="Boxed Data abstract complex type" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCL_BOXED_DATA">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCL_BOXED_COMPLEX_TYPE" REFCLSNAME="ZCL_BOXED_DATA" VERSION="1" STATE="1"/>
  <method CLSNAME="ZCL_BOXED_COMPLEX_TYPE" CMPNAME="MOVE_CORRESPONDING" VERSION="1" LANGU="E" DESCRIPT="Move corresponding from this complex type to target" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_COMPLEX_TYPE" CMPNAME="MOVE_CORRESPONDING" SCONAME="TARGET" VERSION="1" LANGU="E" DESCRIPT="Boxed Data abstract complex type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_COMPLEX_TYPE"/>
   <source>method move_corresponding.
  field-symbols: &lt;fs_target&gt; type any,
                 &lt;fs_source&gt; type any.

  assign data-&gt;* to &lt;fs_source&gt;.
  assign target-&gt;data-&gt;* to &lt;fs_target&gt;.

  &quot;... Same types
  if me-&gt;boxed_type eq target-&gt;boxed_type.
    move-corresponding &lt;fs_source&gt; to &lt;fs_target&gt;.
  else.
    data: lv_text type string.
    lv_text = |The types { get_abap_type( ) } and { target-&gt;get_abap_type( ) }|.
    lv_text = |{ lv_text } are not compatible for move_corresponding( )|.
    raise exception type zcx_boxed_type_mismatch
      exporting
        text = lv_text.
  endif.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_MAPPING" VERSION="1" LANGU="E" DESCRIPT="Boxed Data Binding" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="MAP_STRUCT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="20 " TYPESRC_LENG="0 " TYPESRC="begin of map_struct,
      path type string,
      conformer type ref to zif_boxed_conformer,
    end of map_struct
"/>
  <friends CLSNAME="ZCL_BOXED_MAPPING" REFCLSNAME="ZCL_BOXED_DATA" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="_MAP_TAB" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="64 " TYPESRC_LENG="63 " TYPESRC="_map_tab type hashed table of map_struct with unique key path
"/>
  <attribute CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="_TARGET" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="ADD" VERSION="1" LANGU="E" DESCRIPT="Add a path format &apos;source-path:target-path&apos;" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="ADD" SCONAME="PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="ADD" SCONAME="CONFORMER" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_BOXED_CONFORMER" PAROPTIONL="X"/>
   <source>method add.
    data: ls_map type map_struct.
    read table _map_tab with key path = path transporting no fields.

    if sy-subrc eq 0.
      &quot;... ERROR!
      return.
    endif.

    ls_map-path = path.
    ls_map-conformer = conformer.
    insert ls_map into table _map_tab.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="CONSTRUCTOR" SCONAME="TARGET" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA" PAROPTIONL="X"/>
   <source>method CONSTRUCTOR.
    _target = target.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="GET_TARGET" VERSION="1" LANGU="E" DESCRIPT="Returns the target of this mapping" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="GET_TARGET" SCONAME="TARGET" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method GET_TARGET.
    target = _target.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="SET_TARGET" VERSION="1" LANGU="E" DESCRIPT="Sets the target of this mapping" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_MAPPING" CMPNAME="SET_TARGET" SCONAME="TARGET" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method SET_TARGET.
    _target = target.
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_TABLE_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Abstract Boxed Table Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_TABLE_EXCEPTION" CMPNAME="ZCX_BOXED_TABLE_EXCEPTION" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_TABLE_EXCEPTION" REFCLSNAME="ZCX_BOXED_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_BOXED_PACKER" VERSION="1" LANGU="E" DESCRIPT="Boxes Data to a correct Boxed type" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <friends CLSNAME="ZCL_BOXED_PACKER" REFCLSNAME="ZCL_BOXED_METHOD" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_BOXED_PACKER" REFCLSNAME="ZCL_BOXED_STRUCT" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_BOXED_PACKER" REFCLSNAME="ZCL_BOXED_TABLESET" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_builder definition create public.
  public section.
    methods constructor
      importing
        definition type string.
    methods build
      returning
        value(boxed_data) type ref to zcl_boxed_data.
  protected section.
  private section.
    types:
      begin of creation,
        type      type string,
        name      type string,
        value     type ref to data,
        abap_type type ref to cl_abap_datadescr,
        comp_tab  type cl_abap_structdescr=&gt;component_table,
      end of creation.
    data: _definition type string.
    data: _creations type standard table of creation.
    data: _create_index type i.
    data: _result type ref to zcl_boxed_data.
    methods reset_creations.
    methods increment.
    methods decrement.
    methods append_creation
      importing
        element type ref to cl_sxml_open_element.
    methods add_value
      importing
        element type ref to cl_sxml_value.
    methods build_type.
    methods get_json_relative_type
      importing
        type           type string
      returning
        value(rv_type) type string.
endclass.

class lcl_builder implementation.

  method constructor.
    _definition = definition.
  endmethod.

  method build.
*    ... Sanity check, return already created
*    if _result is initial.
*
*      ... Create the reader
*      data(lr_reader) = cl_sxml_string_reader=&gt;create( cl_abap_codepage=&gt;convert_to( _definition ) ).
*
*      ... Read the first node
*      data(node) = lr_reader-&gt;read_next_node( ).
*
*      ... For each node
*      while node is not initial.
*        case node-&gt;type.
*          when if_sxml_node=&gt;co_nt_element_open.
*
*            ... Increment
*            increment( ).
*
*            ... Append
*            append_creation( cast cl_sxml_open_element( node ) ).
*
*          when if_sxml_node=&gt;co_nt_value.
*
*            ... Add the value
*            add_value( cast cl_sxml_value( node ) ).
*
*          when if_sxml_node=&gt;co_nt_element_close.
*
*            ... Build the type
*            build_type( ).
*
*            ... Decrement
*            decrement( ).
*          when others.
*            ... Error scenario?
*        endcase.
*
*        node = lr_reader-&gt;read_next_node( ).
*      endwhile.
*    endif.
*
*    ... Return the result
*    boxed_data = _result.
  endmethod.

  method reset_creations.
    clear : _creations, _create_index.
  endmethod.

  method get_json_relative_type.
    case type.
      when &apos;object&apos;.
        rv_type = &apos;structure&apos;.
      when &apos;array&apos;.
        rv_type = &apos;table&apos;.
      when &apos;num&apos;.
        rv_type = &apos;integer&apos;.
      when &apos;str&apos;.
        rv_type = &apos;string&apos;.
    endcase.
  endmethod.

  method increment.
    _create_index = _create_index + 1.
  endmethod.

  method decrement.
    _create_index = _create_index - 1.
  endmethod.

  method append_creation.
*    data: ls_creation type creation.
*
*    &quot;... Set the type
*    ls_creation-type = get_json_relative_type( element-&gt;if_sxml_named~qname-name ).
*
*    &quot;... Get attributes
*    data(attributes) = element-&gt;if_sxml_open_element~get_attributes( ).
*
*    if lines( attributes ) gt 0.
*      &quot;... Literally only occurs when this element is in a structure
*      ls_creation-name = cast if_sxml_attribute( attributes[ 1 ] )-&gt;get_value( ).
*    endif.
*
*    &quot;... Append the entry
*    append ls_creation to _creations.
  endmethod.

  method add_value.
*    field-symbols: &lt;fs_value&gt; type any.
*
*    &quot;... Read the last entry
*    read table _creations index lines( _creations ) assigning field-symbol(&lt;fs_creation&gt;).
*
*    &quot;... Set the value
*    create data &lt;fs_creation&gt;-value type string.
*    assign &lt;fs_creation&gt;-value-&gt;* to &lt;fs_value&gt;.
*    &lt;fs_value&gt; = element-&gt;if_sxml_value_node~get_value( ).
  endmethod.

  method build_type.
*    data: ls_creation type creation,
*          ls_comp     type line of cl_abap_structdescr=&gt;component_table.
*    field-symbols: &lt;fs_table&gt; type any table,
*                   &lt;fs_value&gt; type any,
*                   &lt;fs_entry&gt; type any.
*
*    &quot;... Read the indexed creation
*    read table _creations index _create_index assigning field-symbol(&lt;fs_creation&gt;).
*
*    &quot;... Special logic is required when entry is a table or structure
*    case &lt;fs_creation&gt;-type.
*      when &apos;table&apos;.
*        loop at _creations from _create_index + 1 to lines( _creations ) into ls_creation.
*          if &lt;fs_creation&gt;-abap_type is not bound.
*            &quot;... Get the descr
*            &lt;fs_creation&gt;-abap_type = cl_abap_tabledescr=&gt;get( ls_creation-abap_type ).
*
*            &quot;... Create the table
*            create data &lt;fs_creation&gt;-value type handle &lt;fs_creation&gt;-abap_type.
*            assign &lt;fs_creation&gt;-value-&gt;* to &lt;fs_table&gt;.
*          endif.
*
*          &quot;... Assign and insert the value
*          assign ls_creation-value-&gt;* to &lt;fs_entry&gt;.
*          insert &lt;fs_entry&gt; into table &lt;fs_table&gt;.
*        endloop.
*
*        &quot;... Remove the remaining entries
*        delete _creations from _create_index + 1 to lines( _creations ).
*      when &apos;structure&apos;.
*        loop at _creations from _create_index + 1 to lines( _creations ) into ls_creation.
*          ls_comp-name = ls_creation-name.
*          ls_comp-type = ls_creation-abap_type.
*          append ls_comp to &lt;fs_creation&gt;-comp_tab.
*        endloop.
*
*        &lt;fs_creation&gt;-abap_type = cl_abap_structdescr=&gt;get( &lt;fs_creation&gt;-comp_tab ).
*
*        &quot;... Create the structure
*        create data &lt;fs_creation&gt;-value type handle &lt;fs_creation&gt;-abap_type.
*        assign &lt;fs_creation&gt;-value-&gt;* to &lt;fs_entry&gt;.
*
*        &quot;... Unfortunately we need to set all the values too which means looping again
*        loop at _creations from _create_index + 1 to lines( _creations ) into ls_creation.
*          assign component ls_creation-name of structure &lt;fs_entry&gt; to field-symbol(&lt;fs_attribute&gt;).
*          assign ls_creation-value-&gt;* to &lt;fs_value&gt;.
*          &lt;fs_attribute&gt; = &lt;fs_value&gt;.
*        endloop.
*
*        &quot;... Remove the remaining entries
*        delete _creations from _create_index + 1 to lines( _creations ).
*      when &apos;string&apos;.
*        &lt;fs_creation&gt;-abap_type = cl_abap_elemdescr=&gt;get_string( ).
*      when &apos;integer&apos;.
*        &lt;fs_creation&gt;-abap_type = cl_abap_elemdescr=&gt;get_i( ).
*    endcase.
*
  endmethod.
endclass.</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_BOXED_PACKER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CO_TYPE_ELEMENT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ELEMENT&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CO_TYPE_OBJECT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTVALUE="&apos;OBJECT&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CO_TYPE_REF" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTVALUE="&apos;REF&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CO_TYPE_STRUCT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="&apos;STRUCT&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CO_TYPE_TABLESET" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="&apos;TABLESET&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_BOXED_PACKER" CMPNAME="BOX" VERSION="1" LANGU="E" DESCRIPT="Box a data type" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="BOX" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="BOX" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method box.
  data: lr_descr type ref to cl_abap_typedescr.
  lr_descr = cl_abap_typedescr=&gt;describe_by_data( p_data = value ).

  boxed_data = internal_box( value = value type_descr = lr_descr ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CREATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CREATE" SCONAME="DEFINITION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="CREATE" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method create.
    &quot;... For now just use the 1 builder
*    boxed_data = new lcl_builder( definition )-&gt;build( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_BOXED_PACKER" CMPNAME="INTERNAL_BOX" VERSION="1" LANGU="E" DESCRIPT="Performs the internal boxing" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="INTERNAL_BOX" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="INTERNAL_BOX" SCONAME="TYPE_DESCR" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="INTERNAL_BOX" SCONAME="USE_REF" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_BOXED_PACKER" CMPNAME="INTERNAL_BOX" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <source>method internal_box.
  case type_descr-&gt;kind.
    when cl_abap_typedescr=&gt;kind_elem.
      create object boxed_data
        type
          (&apos;ZCL_BOXED_ELEMENT&apos;)
        exporting
          value                 = value
          type_descr            = type_descr.
    when cl_abap_typedescr=&gt;kind_struct.
      create object boxed_data
        type
          (&apos;ZCL_BOXED_STRUCT&apos;)
        exporting
          value                = value
          type_descr           = type_descr.
    when cl_abap_typedescr=&gt;kind_table.
      create object boxed_data
        type
          (&apos;ZCL_BOXED_TABLESET&apos;)
        exporting
          value                  = value
          type_descr             = type_descr.
    when cl_abap_typedescr=&gt;kind_class or cl_abap_typedescr=&gt;kind_intf.
      create object boxed_data
        type
          (&apos;ZCL_BOXED_OBJECT&apos;)
        exporting
          value                = value
          type_descr           = type_descr.
    when cl_abap_typedescr=&gt;kind_ref.
      create object boxed_data
        type
          (&apos;ZCL_BOXED_REF&apos;)
        exporting
          value             = value
          type_descr        = type_descr.
    when others.
      &quot;... ERROR
  endcase.
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_DYNAMIC_CHECK" VERSION="1" LANGU="E" DESCRIPT="Boxed DYNAMIC check exception with text" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_DYNAMIC_CHECK" CMPNAME="TEXT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_BOXED_DYNAMIC_CHECK" CMPNAME="ZCX_BOXED_DYNAMIC_CHECK" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_DYNAMIC_CHECK" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_BOXED_STATIC_CHECK" VERSION="1" LANGU="E" DESCRIPT="Boxed STATIC check exception with text" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_BOXED_STATIC_CHECK" CMPNAME="TEXT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_BOXED_STATIC_CHECK" CMPNAME="ZCX_BOXED_STATIC_CHECK" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SOTR_CONC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " LOCKED="X" TYPESRC_LENG="0 ">
   <sotr PAKET="$TMP" CREA_LAN="E" TRALA_TYPE="1" LST_IMPORT="00000000" TRALA_VEC="00000000000000000000" CATGY_VEC="00000000000000000000" OBJID_VEC="08000000000000000000">
    <sotrText LANGU="E" LFD_NUM="0001" FLAG_CNTXT="X" STATUS="R" VERSION="0002" LENGTH="255" TEXT="&amp;TEXT&amp;"/>
   </sotr>
  </attribute>
  <inheritance CLSNAME="ZCX_BOXED_STATIC_CHECK" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <INTF CLSNAME="ZIF_BOXED_ITERATOR" VERSION="1" LANGU="E" DESCRIPT="Iterates over a table of boxed data" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_BOXED_ITERATOR" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <method CLSNAME="ZIF_BOXED_ITERATOR" CMPNAME="HAS_NEXT" VERSION="1" LANGU="E" DESCRIPT="Returns true if the iteration has more elements" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_BOXED_ITERATOR" CMPNAME="HAS_NEXT" SCONAME="RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_BOXED_ITERATOR" CMPNAME="NEXT" VERSION="1" LANGU="E" DESCRIPT="Return the next element in the iteration" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_BOXED_ITERATOR" CMPNAME="NEXT" SCONAME="BOXED_DATA" VERSION="1" LANGU="E" DESCRIPT="Boxed Data" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_BOXED_CONFORMER" VERSION="1" LANGU="E" DESCRIPT="Conforms a boxed mapping" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_BOXED_CONFORMER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <method CLSNAME="ZIF_BOXED_CONFORMER" CMPNAME="TRANSFORM" VERSION="1" LANGU="E" DESCRIPT="Transform an input" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_BOXED_CONFORMER" CMPNAME="TRANSFORM" SCONAME="INPUT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <parameter CLSNAME="ZIF_BOXED_CONFORMER" CMPNAME="TRANSFORM" SCONAME="RESULT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
  </method>
  <method CLSNAME="ZIF_BOXED_CONFORMER" CMPNAME="VALIDATE" VERSION="1" LANGU="E" DESCRIPT="Validates an input" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_BOXED_CONFORMER" CMPNAME="VALIDATE" SCONAME="INPUT" VERSION="1" LANGU="E" DESCRIPT="Boxed Data - A COPY of a data type wrapped as an object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_BOXED_DATA"/>
   <parameter CLSNAME="ZIF_BOXED_CONFORMER" CMPNAME="VALIDATE" SCONAME="VALID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
 </INTF>
 <PROG NAME="ZBOXED_DATA_EXAMPLES" VARCL="X" SUBC="1" RMAND="421" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Program ZBOXED_DATA_EXAMPLES" LENGTH="28 "/>
   </language>
  </textPool>
  <source>report zboxed_data_examples.

*&amp;---------------------------------------------------------------------*
*&amp; Report  ZBOXED_DATA_EXAMPLES
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*
types:
  begin of person_adr,
    number type i,
    street type string,
    city type string,
    postcode type string,
  end of person_adr,
  person_adr_tab type table of person_adr with non-unique key number street,
  begin of person,
    first_name type string,
    last_name type string,
    addresses type person_adr_tab,
  end of person.

data: lr_box type ref to zcl_boxed_data,
      lr_tab type ref to zcl_boxed_tableset,
      lt_str type standard table of string,
      lv_str type string.

data: lt_persons type standard table of person,
      ls_person type person,
      ls_address type person_adr.

ls_person-first_name = &apos;Bob&apos;.
ls_person-last_name = &apos;Smith&apos;.
ls_address-number = 22.
ls_address-street = &apos;Awesome street&apos;.
append ls_address to ls_person-addresses.
ls_address-number = 23.
ls_address-street = &apos;Cool street&apos;.
append ls_address to ls_person-addresses.
append ls_person to lt_persons.

ls_person-first_name = &apos;Jimmy&apos;.
ls_person-last_name = &apos;Secondguymaster&apos;.
ls_address-number = 33.
ls_address-street = &apos;Something street&apos;.
append ls_address to ls_person-addresses.
ls_address-number = 34.
ls_address-street = &apos;Other street&apos;.
append ls_address to ls_person-addresses.
append ls_person to lt_persons.

lr_tab ?= zcl_boxed_packer=&gt;box( lt_persons ).

*lr_box = lr_tab-&gt;resolve_path( &apos;[1]-first_name&apos; ).

lr_box = lr_tab-&gt;find( |[first_name = &apos;Jimmy&apos;]| ).

*lv_str = lr_box-&gt;to_string( ).

write lv_str.

write &apos;End of story&apos;.</source>
 </PROG>
</nugget>
